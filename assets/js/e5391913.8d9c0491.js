"use strict";(self.webpackChunkeducation_docs=self.webpackChunkeducation_docs||[]).push([[379],{9967:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var n=s(4848),i=s(8453);const o={},a="Distributed Coordination: Consensus Protocols",r={id:"courses/blockchain-developer-bootcamp/S01-fundamentals/M2-consensus/L2-consensus-additional/index",title:"Distributed Coordination: Consensus Protocols",description:"After learning about cryptography, we know how to create an identity, how to make sure no one has messed with a file, and how to capture a user's intent all in a decentralized peer-to-peer way. This is all well and good for current interactions or things we are doing now on a network, but how do we agree on things that have happened in the past? That is, how do actors in a network we coordinate and agree on the series of events that have led to the current state of the network? How do we know someone really does have digital money they can send to us and are not making it up? How do all the actors in the network then maintain that knowledge in a secure way? This is what we're going to learn in this module.",source:"@site/docs/courses/blockchain-developer-bootcamp/S01-fundamentals/M2-consensus/L2-consensus-additional/index.md",sourceDirName:"courses/blockchain-developer-bootcamp/S01-fundamentals/M2-consensus/L2-consensus-additional",slug:"/courses/blockchain-developer-bootcamp/S01-fundamentals/M2-consensus/L2-consensus-additional/",permalink:"/educationdao.xyz/docs/courses/blockchain-developer-bootcamp/S01-fundamentals/M2-consensus/L2-consensus-additional/",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"oliver renwick",lastUpdatedAt:1721061896e3,frontMatter:{},sidebar:"docSidebar",previous:{title:"Consensus Conclusion",permalink:"/educationdao.xyz/docs/courses/blockchain-developer-bootcamp/S01-fundamentals/M2-consensus/L11-consensus-conclusion/"},next:{title:"Raft Consensus Tutorial",permalink:"/educationdao.xyz/docs/courses/blockchain-developer-bootcamp/S01-fundamentals/M2-consensus/L3-raft/"}},l={},c=[{value:"Development of Distributed Computing",id:"development-of-distributed-computing",level:2},{value:"Conclusion",id:"conclusion",level:2},{value:"Additional Links",id:"additional-links",level:2},{value:"Basic",id:"basic",level:3},{value:"Advanced",id:"advanced",level:3}];function d(e){const t={a:"a",em:"em",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"distributed-coordination-consensus-protocols",children:"Distributed Coordination: Consensus Protocols"}),"\n",(0,n.jsxs)(t.p,{children:["After learning about cryptography, we know how to create an identity, how to make sure no one has messed with a file, and how to capture a user's intent all in a decentralized peer-to-peer way. This is all well and good for current interactions or things we are doing ",(0,n.jsx)(t.em,{children:"now"})," on a network, but how do we agree on things that have happened in the past? That is, how do actors in a network we coordinate and agree on the series of events that have led to the current state of the network? How do we know someone really ",(0,n.jsx)(t.em,{children:"does"})," have digital money they can send to us and are not making it up? How do all the actors in the network then maintain that knowledge in a secure way? This is what we're going to learn in this module."]}),"\n",(0,n.jsxs)(t.p,{children:["To understand how all the actors in a network can coordinate and agree about the historical state of a blockchain network we will learn about ",(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Consensus_(computer_science)",children:"consensus"})}),". Distributed consensus is not only used in blockchain, to be clear. Any internet service that needs to coordinate their servers all over the globe (which is all the major internet services) uses distributed consensus mechanisms to make that happen. Blockchain takes traditional distributed consensus one step further. We'll see what that step is once we understand the historical and fundamental principles of distributed computing."]}),"\n",(0,n.jsxs)(t.p,{children:["(Note: In this section, we will use the terms ",(0,n.jsx)(t.strong,{children:"Distributed Computing"}),", ",(0,n.jsx)(t.strong,{children:"Distributed Systems"}),", ",(0,n.jsx)(t.strong,{children:"Distributed Consensus"}),", and ",(0,n.jsx)(t.strong,{children:"Distributed Coordination"})," interchangeably. We'll also be speaking about consensus strictly in the computer scientific sense. Later in the course, we'll discuss consensus among people in a network, typically called ",(0,n.jsx)(t.strong,{children:"governance"}),".)"]}),"\n",(0,n.jsx)(t.h2,{id:"development-of-distributed-computing",children:"Development of Distributed Computing"}),"\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Distributed_computing",children:"Distributed Computing"}),' became an important field of study in the 1970s when airplanes started using electronic control systems. Airline manufacturers wanted to make sure that if a certain part of the electronics gave out while the plane was in the air, the whole plane wouldn\'t shut down. In the scenario of an airplane, the "bad actor" is not a hacker trying to purposefully disable the entire airplane, but rather a single part that is not behaving as it should. As a result, researchers began researching and developing ',(0,n.jsx)(t.strong,{children:"consensus protocols"})," for the airplane computer systems."]}),"\n",(0,n.jsxs)(t.p,{children:['At the most basic level, "consensus protocols are used to allow computers to work together" and "let different servers agree on the state of a system." (',(0,n.jsx)(t.a,{href:"https://softwareengineeringdaily.com/2018/03/26/consensus-systems-with-ethan-buchman/",children:"Software Engineering Daily"}),"). For the airplane manufacturers, a good consensus protocol would continue to function with some errors. This way, if one or two things failed, the entire system wouldn't fail. The ability of a consensus protocol to adapt to failure is called ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Resilience_(network)",children:"resilience."})]}),"\n",(0,n.jsxs)(t.p,{children:["Crucially, early work around distributed computing and consensus protocols dealt with ",(0,n.jsx)(t.em,{children:"non-adversarial systems"}),". This meant that any of the faults that were happening in a computer network, like an airplane, were the result of natural system errors (power failure, faulty parts, etc), not some sort of active meddling or hacking. This has now developed to encompass much more than aerospace technology. As we mentioned before, it now also covers many digital services, such as:"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"Any multi-party real-time communication stream (like a social media feed)"}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"An online media streaming service which requires multiple regional servers holding and updating the exact same information on customers"}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"A search engine service that needs to maintain and update indexed information across many regions"}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["Consensus protocols help these systems maintain historical information also called ",(0,n.jsx)(t.strong,{children:"state."})," Broadly speaking, state can be defined as a set of variables describing a certain system at a specific time. Let\u2019s describe that in a real-world situation. Take a look around at whatever environment you\u2019re in\u2013\u2013bus station, coffee shop, office\u2013\u2013and pick out a few variables you could use to describe it. If you\u2019re inside a room, you could describe any number of things:"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"The number of walls"}),"\n",(0,n.jsx)(t.li,{children:"The types of furniture"}),"\n",(0,n.jsx)(t.li,{children:"The placement of furniture"}),"\n",(0,n.jsx)(t.li,{children:"The number of people"}),"\n",(0,n.jsx)(t.li,{children:"The kind of light in the room"}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Taken all together, these variables will paint a picture of the room. And if things change (say, you turn off a light), we'll update \"The kind of light in the room\" variable, which changes the state. If multiple people needed to maintain a record about the state of our room, we'd have to find a way to communicate this state change. Consensus protocols help us do exactly that: agree on a sequential series of system state which allows all network participants adhering to the consensus protocol to have a similar understanding of the historical changes adding up to the current network state."}),"\n",(0,n.jsxs)(t.p,{children:["For a distributed computer network, state typically involves technical information about critical actors in a system. For a social media site, the state includes when a user logged in, what they did, where they were, etc. For an airplane or spaceship, the state includes current status of different parts of the ship, fuel or energy levels, temperature or atmospheric data, etc. As each individual actor in the network uses the consensus protocol to propagate the changes they're doing locally and update their own state based on updates they're getting from others, a historical understanding of the system begins to ",(0,n.jsx)(t.em,{children:"emerge"})," from these state changes. This coordination of state among multiple actors in a common system allows for many interesting systems, including many of the digital services we use today."]}),"\n",(0,n.jsxs)(t.p,{children:['Please note that we\'re using terms like "actors" or "participants" to describe the active parties in a distributed system. Despite the name, these traditionally refer to machines or computers in a network more commonly called ',(0,n.jsx)(t.strong,{children:"nodes"}),". It can be confusing but just try to remember these are general models we're discussing. Once we get into application and practice, it may be easier to understand."]}),"\n",(0,n.jsxs)(t.p,{children:["A distributed system where multiple actors are using a consensus protocol to maintain state can be called a ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Finite-state_machine",children:"state machine or finite state machine."}),' This is fairly technical, but it simply requires us to expand our understanding of a machine, which we typically think of as a metal box containing small electronics connected by circuits. "State machine" allows us to consider larger systems, such as a cellphone network or all the electronic parts comprising an airplane, as themselves being machines comprised of nodes consistently maintaining a global state among themselves without a central point of failure.']}),"\n",(0,n.jsx)(t.p,{children:"Along with state, distributed consensus relies on a few concepts, such as:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Node_(networking)",children:"Nodes"})}),' In a strict technical sense, a node is defined as "an electronic device that is attached to a network, and is capable of creating, receiving, or transmitting information over a communication channel." Distributed systems are comprised of nodes. We also call nodes participants or actors. Nodes typically fall into three categories: Leaders (nodes responsible for proposing values), Acceptors (nodes that receive values from Leader and accept them), Processors (nodes that do some operations or processing on received values) (',(0,n.jsx)(t.a,{href:"https://distsys.substack.com/p/impossibility-of-distributed-consensus",children:"source"}),"). These roles are not exclusive, a single node may take on one, two, or all three roles."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Message Propagation"})," A node can update its state in a distributed network exclusively through messages. How those messages pass or propagate through the network is a critical part of maintaining state. If a node cannot pass a message through a network, there cannot be a unified state that all network nodes agree on. How nodes in a network propagate their messages is known as its ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Network_topology",children:"topology."})," Centralized systems, as shown below, can quickly distribute messages. However, they aren't particularly resilient (if the single central node collapses, so does the network). As a result, distributed systems have developed their own peer-to-peer protocols. Below is a famous diagram showing centralized, decentralized and distributed network topologies: ",(0,n.jsx)(t.img,{alt:"diagram of centralized, decentralized and distributed systems",src:s(2342).A+"",width:"554",height:"415"})]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Time"})," The notion of time is very important in a distributed system as it creates a sort of order for the larger system. Ordering events that occur in a system is particularly important. Think about making breakfast, for example. If you mix up the order of a series of actions, like eating your eggs before you cook them, it can create chaos and confusion. ",(0,n.jsx)(t.a,{href:"https://dean.eigenmann.me/blog/2020/01/06/time-clocks-and-order/",children:"Here's an article"})," from Dean Eigenmann discussing the concept of Time, Clocks, and Order in distributed systems."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Periods"})," Related to the idea of time, every consensus protocol requires discrete periods of activity. Perhaps a node is waiting to hear from a leader, perhaps a series of transactions are being prepared for a block, perhaps the nodes are passing around the latest agreed-upon state. These periods are critical to any consensus protocol. In blockchain systems, these periods typically revolve around the creation and propagation of transactions in a ",(0,n.jsx)(t.em,{children:"block."})]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Fault_tolerance",children:"Fault Tolerance"})})," This is a formal description of resilience: How many mistakes can a system tolerate before it will collapse completely? Put another way, how many bad nodes can we have in a system before the system ceases to propagate state? Leslie Lamport proposed a subset of fault tolerance called ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Byzantine_fault",children:"Byzantine Fault Tolerance."})," We discussed it briefly in the video before. Essentially, the most amount of fault a distributed network can absorb is one-third. So, if 2/3rds of a system are still available and coordinating, the system can still run. Because of this famous thought experiment, you may see fault tolerance referred to as Byzantine Fault tolerance or Practical Byzantine Fault Tolerance. However, it's similar to how a rectangle is not a square but a square is a rectangle: Not all fault tolerance is Byzantine fault tolerance. We'll discuss more of this later in the section on trustless consensus."]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["Please note: Distributed consensus outside of blockchain only deals with systems that are non-adversarial meaning all the nodes trust each other. This means the only errors that would show up would be from things like power failures or misbehaving parts, etc. You would not attribute malice to any misbehaving actor. Blockchain's big innovation, which we'll discuss later, was the creation of consensus protocols in adversarial networks in which you ",(0,n.jsx)(t.em,{children:"must"})," assume everyone is out to get you. This is what we call ",(0,n.jsx)(t.strong,{children:"trustless consensus"}),"."]}),"\n",(0,n.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,n.jsxs)(t.p,{children:["In our search for the primitives underlying blockchain technology, consensus holds an important piece by allowing a network to have a memory of its own history, which we are calling ",(0,n.jsx)(t.em,{children:"state."}),' We saw how cryptography allowed us to ensure peer-to-peer authenticity in the moment. Consensus protocols allow us to "save" that authenticity across time by facilitating the coordination of all network nodes around a global state. It also allows new participants (nodes) to enter the system and get "up to date" on what has happened previously in the system.']}),"\n",(0,n.jsxs)(t.p,{children:["The next section is an excellent overview of a basic consensus protocol system called ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Raft_(algorithm)",children:"Raft."})," Raft is a simplified consensus algorithm which we feel makes it more approachable to understand. However, Raft is a production-ready consensus protocol ",(0,n.jsx)(t.a,{href:"https://www.dbta.com/Columns/MongoDB-Matters/MongoDB-Matters-MongoDB-Strives-for-a-Perfect-Consensus-132930.aspx",children:"used"})," by such major projects as ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/MongoDB",children:"MongoDB."})," The website The Secret Lives of Data has created an extraordinary walkthrough of Raft, which we hope will illustrate consensus in a concrete way."]}),"\n",(0,n.jsx)(t.h2,{id:"additional-links",children:"Additional Links"}),"\n",(0,n.jsx)(t.h3,{id:"basic",children:"Basic"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"http://thesecretlivesofdata.com/raft/",children:"Interactive: Raft: Understandable Distributed Consensus"})," A really excellent, interactive walkthrough of the Raft consensus protocol, a basic consensus protocol. The simple and easy way in which the tutorial walks through the consensus mechanism will help you understand how consensus protocols work on a practical level."]}),"\n",(0,n.jsxs)(t.li,{children:["Article: ",(0,n.jsx)(t.a,{href:"https://www.preethikasireddy.com/post/lets-take-a-crack-at-understanding-distributed-consensus",children:"Let's Take a Crack at Understanding Distributed Consensus"})," (Preethi Kasireddy)"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://distsys.substack.com/",children:"Article Series: Distributed Systems Digest"}),' (Dean Eigenmann) This is an excellent series of articles discussing distributed systems, in an approachable way. If you click "Let me read it first," you can access the articles.']}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://softwareengineeringdaily.com/2018/03/26/consensus-systems-with-ethan-buchman/",children:"Podcast: Distributed Systems with Ethan Buchman (Software Engineering Daily)"})," An overview on distributed systems, including the history of their development"]}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://consensys.net/blog/blockchain-explained/want-to-really-understand-blockchain-you-need-to-understand-state/",children:"Article: Want to Really Understand Blockchain? You Need to Understand State (ConsenSys)"})}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://medium.com/coinmonks/a-brief-overview-of-kademlia-and-its-use-in-various-decentralized-platforms-da08a7f72b8f",children:"Article: A Brief Overview of Kademlia and Its Use In Various Decentralized Platforms"})," The Kademlia protocol is a peer-to-peer file sharing system used by many decentralized systems, including Ethereum."]}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://explained-from-first-principles.com/internet/#nodes-and-links",children:"Article: Nodes and Links (Explained from First Principles)"})}),"\n",(0,n.jsxs)(t.li,{children:["Wikipedia: ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Consensus_(computer_science)",children:"Consensus Methods,"})," ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Distributed_computing",children:"Distributed Computing,"})," ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Resilience_(network)",children:"Network Resilience,"})," ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Fault_tolerance",children:"Fault Tolerance,"})," ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/State_(computer_science)",children:"Network State,"})," ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Byzantine_fault",children:"Byzantine Fault Tolerance"})," ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Finite-state_machine",children:"State Machines,"})," ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/List_of_P2P_protocols",children:"Peer-to-Peer Protocols,"})," ",(0,n.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Gossip_protocol",children:"Gossip Protocol"})]}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"advanced",children:"Advanced"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.a,{href:"http://www.distributedsystemscourse.com/",children:"Course: Distributed Systems"})}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.a,{href:"http://elaineshi.com/docs/blockchain-book.pdf",children:"Textbook: Foundations of Distributed Consensus and Blockchains (Elaine Shi)"})," An advanced and extremely technical but comprehensive view on distributed consensus as it pertains to blockchain development."]}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.a,{href:"https://lamport.azurewebsites.net/pubs/byz.pdf",children:"Academic Article: Leslie Lamport's Byzantine Generals Problem"})}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.a,{href:"https://lamport.azurewebsites.net/pubs/time-clocks.pdf",children:"Article: Times, Clocks and Ordering (Leslie Lamport)"})}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.a,{href:"https://github.com/decanus/research/issues/10",children:'GitHub: Notes for Dean Eigenmann\'s Article "Times, Clocks and Ordering"'})}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.a,{href:"https://webtorrent.github.io/workshop/",children:"GitHub: P2P Workshops"})," This site has a series of exercises to learn about building P2P networks"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},2342:(e,t,s)=>{s.d(t,{A:()=>n});const n=s.p+"assets/images/network-topology-3c330008828ce313ea6d3a59c5aec8cf.png"},8453:(e,t,s)=>{s.d(t,{R:()=>a,x:()=>r});var n=s(6540);const i={},o=n.createContext(i);function a(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);