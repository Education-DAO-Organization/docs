"use strict";(self.webpackChunkeducation_docs=self.webpackChunkeducation_docs||[]).push([[821],{3255:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>d,contentTitle:()=>n,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var r=t(4848),o=t(8453);const i={},n="The Graph",s={id:"courses/blockchain-developer-bootcamp/S07-additional-topics/L3-the-graph/index",title:"The Graph",description:"The Graph is a decentralized protocol for indexing and querying data on public blockchain infrastructure. The Graph organizes and makes it easy to query on-chain data in a way that was not possible in the past, with GraphQL. Querying blockchain data is difficult. Node clients can be inconsistent, application developers are required to write proprietary code and build centralized servers for ingesting the data, and they need to manage their own APIs for uptime and optimal UX. The Graph aims to solve this problem by abstracting the back-end, pre-aggregate data and making it significantly more efficient for developers to retrieve on-chain data. See video below:",source:"@site/docs/courses/blockchain-developer-bootcamp/S07-additional-topics/L3-the-graph/index.md",sourceDirName:"courses/blockchain-developer-bootcamp/S07-additional-topics/L3-the-graph",slug:"/courses/blockchain-developer-bootcamp/S07-additional-topics/L3-the-graph/",permalink:"/educationdao.xyz/docs/courses/blockchain-developer-bootcamp/S07-additional-topics/L3-the-graph/",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"oliver renwick",lastUpdatedAt:1721137902e3,frontMatter:{},sidebar:"docSidebar",previous:{title:"Filecoin",permalink:"/educationdao.xyz/docs/courses/blockchain-developer-bootcamp/S07-additional-topics/L2-filecoin/"},next:{title:"Zero-Knowledge Proofs",permalink:"/educationdao.xyz/docs/courses/blockchain-developer-bootcamp/S07-additional-topics/L4-zkp/"}},d={},l=[{value:"What is a Subgraph?",id:"what-is-a-subgraph",level:2},{value:"Why do we care about Subgraphs (dApp perspective)",id:"why-do-we-care-about-subgraphs-dapp-perspective",level:2},{value:"How to build a Subgraph",id:"how-to-build-a-subgraph",level:2},{value:"Querying from a Frontend Application",id:"querying-from-a-frontend-application",level:2},{value:"API Key Management",id:"api-key-management",level:2},{value:"The Graph Explorer",id:"the-graph-explorer",level:2}];function h(e){const a={a:"a",h1:"h1",h2:"h2",p:"p",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(a.h1,{id:"the-graph",children:"The Graph"}),"\n",(0,r.jsxs)(a.p,{children:[(0,r.jsx)(a.a,{href:"https://thegraph.com/",children:"The Graph"})," is a decentralized protocol for indexing and querying data on public blockchain infrastructure. The Graph organizes and makes it easy to query on-chain data in a way that was not possible in the past, with GraphQL. Querying blockchain data is difficult. Node clients can be inconsistent, application developers are required to write proprietary code and build centralized servers for ingesting the data, and they need to manage their own APIs for uptime and optimal UX. The Graph aims to solve this problem by abstracting the back-end, pre-aggregate data and making it significantly more efficient for developers to retrieve on-chain data. See video below:"]}),"\n",(0,r.jsx)("figure",{class:"video_container",children:(0,r.jsx)("iframe",{src:"https://www.youtube.com/embed/X_2ln79Qb-Q",frameborder:"0",allowfullscreen:"true"})}),"\n",(0,r.jsx)(a.p,{children:"GRT is the native Graph token that is used to coordinate Indexers, Curators and Delegators around providing on-chain data to applications. Node operators, called Indexers, stake and earn GRT for indexing subgraphs and processing queries for dApps, such as querying for aggregate trade volume on DEXs. Delegators contribute to the security of the network by delegating their GRT stake to Indexers and also earning a portion of query fees. Delegation enables Indexers to grow in proportional size on the network and increase their indexing operation to serve more applications. Anyone can delegate GRT to Indexers to secure the network and earn rewards. Curators organize data on The Graph by signaling GRT on useful APIs, called subgraphs. Indexers look out for subgraph signal to understand which subgraphs should be prioritized based on the collective sentiment and aggregate signal."}),"\n",(0,r.jsx)(a.p,{children:"Signaling on a subgraph is a mechanism similar to leaving Yelp reviews, whereby all participants are curating the quality of the ecosystem. Indexers, Delegators, and Curators work together to organize the data for the crypto economy and maintain a useful global API for DeFi and Web3."}),"\n",(0,r.jsx)(a.h2,{id:"what-is-a-subgraph",children:"What is a Subgraph?"}),"\n",(0,r.jsx)(a.p,{children:"In the traditional web stack, databases, servers, and APIs query, filter, sort, paginate, group, and join data before it is returned to some client application usually via some type of http request. These types of data transformations are not possible when reading data directly from Ethereum or other blockchains. In the past, developers were getting around this by building their own centralized indexing servers - pulling data from blockchains, storing it in a database, and exposing it over an API. This required significant engineering and hardware resources that broke the important security properties required for decentralization.\nThrough The Graph\u2019s protocol, developers can deploy subgraphs (open source APIs) to query on-chain data, for dapps like DeFi aggregators, wallets and NFT marketplaces. Alternatively, developers would need to build their own proprietary servers and act as a potential central point of failure for their dapp."}),"\n",(0,r.jsx)(a.p,{children:"See the video below on why subgraphs are important to the dApp ecosystem:"}),"\n",(0,r.jsx)("figure",{class:"video_container",children:(0,r.jsx)("iframe",{src:"https://www.youtube.com/embed/NlmkqQQko5U",frameborder:"0",allowfullscreen:"true"})}),"\n",(0,r.jsx)(a.h2,{id:"why-do-we-care-about-subgraphs-dapp-perspective",children:"Why do we care about Subgraphs (dApp perspective)"}),"\n",(0,r.jsx)(a.p,{children:"Subgraphs enable blockchain data to be accessible via performant and open APIs with rich querying capabilities like enabling filtering, relationships, and full text search. They are a way to define which data you want to get indexed and how to store it. Subgraphs can be built to do pre-aggregations or calculations on their mappings, some are just used to organize on-chain event data. Then, an entity queries that data. This entity could be a dApp (company/developer, etc), or could be a telegram bot, or a discord bot or even a simple user doing a query to find information."}),"\n",(0,r.jsx)(a.p,{children:"The value of using a subgraph when building a dApp is that your application data will always be indexed by a network of indexers, so that users can easily query your smart contract. This means that your API cannot be taken down and ensuring a decentralized network of Indexers and Curators will always serve your dapp\u2019s queries. This also limits the risk of central points of failure. Imagine that no one knows what Wikipedia is because Wikipedia has not built a code to interact with Google\u2019s index, therefore anyone querying searching information will not turn up any results from Wikipedia."}),"\n",(0,r.jsxs)(a.p,{children:["It is vital and in the best interest of the dApp team to develop a subgraph so that information is easily accessible to other developers in the Ethereum community. For example, the Uniswap subgraph is used by Uniswap.info as well as many other projects that are interested in querying Uniswap data such as trade volumes, prices or assets. Subgraphs are written in TypeScript and GraphQL SDL and queried using GraphQL. To learn more about GraphQL and how it will power the decentralized web as a data interoperability layer, read ",(0,r.jsx)(a.a,{href:"https://medium.com/graphprotocol/graphql-will-power-the-decentralized-web-d7443a69c69a",children:"this blog post"})," written by The Graph Co-founder and former Research Lead, Brandon Ramirez. Feel free to also check out The Graph's network documentation for ",(0,r.jsx)(a.a,{href:"https://thegraph.com/docs/about/introduction",children:"more details"}),"."]}),"\n",(0,r.jsx)(a.p,{children:"Video explainer below:"}),"\n",(0,r.jsx)("figure",{class:"video_container",children:(0,r.jsx)("iframe",{src:"https://www.youtube.com/embed/DjnApXmdAKg",frameborder:"0",allowfullscreen:"true"})}),"\n",(0,r.jsx)(a.h2,{id:"how-to-build-a-subgraph",children:"How to build a Subgraph"}),"\n",(0,r.jsxs)(a.p,{children:["For a step by step guide on how to build a Subgraph, check out ",(0,r.jsx)(a.a,{href:"https://thegraph.com/blog/building-with-subgraph-studio",children:"this guide"})," written by DevRel lead, Nader Dabit at Edge & Node."]}),"\n",(0,r.jsx)(a.p,{children:"For a video guide, watch below!"}),"\n",(0,r.jsx)("figure",{class:"video_container",children:(0,r.jsx)("iframe",{src:"https://www.youtube.com/embed/HfDgC2oNnwo",frameborder:"0",allowfullscreen:"true"})}),"\n",(0,r.jsxs)(a.p,{children:["For a more general guide on how to get started with web3, check out ",(0,r.jsx)(a.a,{href:"https://dev.to/dabit3/the-complete-guide-to-full-stack-ethereum-development-3j13",children:"this guide"}),"."]}),"\n",(0,r.jsx)(a.h2,{id:"querying-from-a-frontend-application",children:"Querying from a Frontend Application"}),"\n",(0,r.jsxs)(a.p,{children:["Follow ",(0,r.jsx)(a.a,{href:"https://github.com/graphprotocol/full-stack-graph-app",children:"the guide in Gitpod"})," and ",(0,r.jsx)(a.a,{href:"https://www.youtube.com/watch?v=PjyKPMpahuc",children:"video"})," below:"]}),"\n",(0,r.jsx)("figure",{class:"video_container",children:(0,r.jsx)("iframe",{src:"https://www.youtube.com/watch?v=PjyKPMpahuc",frameborder:"0",allowfullscreen:"true"})}),"\n",(0,r.jsx)(a.h2,{id:"api-key-management",children:"API Key Management"}),"\n",(0,r.jsx)(a.p,{children:"Regardless of whether you\u2019re a dApp developer or a subgraph developer, you\u2019ll need to manage your API keys. This is important for you to be able to query subgraphs because API keys make sure the connections between application services are valid and authorized. This includes authenticating the end user and the device using the application."}),"\n",(0,r.jsxs)(a.p,{children:["The ",(0,r.jsx)(a.a,{href:"https://thegraph.com/studio/",children:"Subgraph Studio"})," will list out existing API keys, which will give you the ability to manage or delete them. For more details, follow along in the video below:"]}),"\n",(0,r.jsx)("figure",{class:"video_container",children:(0,r.jsx)("iframe",{src:"https://www.youtube.com/embed/UrfIpm-Vlgs",frameborder:"0",allowfullscreen:"true"})}),"\n",(0,r.jsx)(a.h2,{id:"the-graph-explorer",children:"The Graph Explorer"}),"\n",(0,r.jsxs)(a.p,{children:["The Graph Explorer is a developer's decentralized portal into the world of subgraphs and network data. The Graph Explorer consists of multiple parts where developers can interact with other subgraph developers, dApp developers, Curators, Indexers, and Delegators. For a general overview of the Graph Explorer, check out the video below or read The Graph's documentation ",(0,r.jsx)(a.a,{href:"https://thegraph.com/docs/explorer",children:"here"}),"."]}),"\n",(0,r.jsx)("figure",{class:"video_container",children:(0,r.jsx)("iframe",{src:"https://www.youtube.com/embed/u224xf7rEBY",frameborder:"0",allowfullscreen:"true"})})]})}function c(e={}){const{wrapper:a}={...(0,o.R)(),...e.components};return a?(0,r.jsx)(a,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,a,t)=>{t.d(a,{R:()=>n,x:()=>s});var r=t(6540);const o={},i=r.createContext(o);function n(e){const a=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function s(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:n(e.components),r.createElement(i.Provider,{value:a},e.children)}}}]);