"use strict";(self.webpackChunkeducation_docs=self.webpackChunkeducation_docs||[]).push([[8352],{3299:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>d});var n=a(4848),r=a(8453);const o={},s="Additional Material: Upgradable Contracts",i={id:"courses/blockchain-developer-bootcamp/S03-smart-contracts/M4-design-patterns/L8-add-material-upgradable-contracts/index",title:"Additional Material: Upgradable Contracts",description:'We wanted to provide another example of an upgradable contract pattern. This pattern uses a separate contract to act as storage to another contract that contains the logic, also known as a "proxy delegate pattern". When you upgrade a contract, all your state is still in the old contract address. Therefore, we say the contract has "Eternal Storage."',source:"@site/docs/courses/blockchain-developer-bootcamp/S03-smart-contracts/M4-design-patterns/L8-add-material-upgradable-contracts/index.md",sourceDirName:"courses/blockchain-developer-bootcamp/S03-smart-contracts/M4-design-patterns/L8-add-material-upgradable-contracts",slug:"/courses/blockchain-developer-bootcamp/S03-smart-contracts/M4-design-patterns/L8-add-material-upgradable-contracts/",permalink:"/educationdao.xyz/docs/courses/blockchain-developer-bootcamp/S03-smart-contracts/M4-design-patterns/L8-add-material-upgradable-contracts/",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"oliver renwick",lastUpdatedAt:1721061896e3,frontMatter:{},sidebar:"docSidebar",previous:{title:"index",permalink:"/educationdao.xyz/docs/courses/blockchain-developer-bootcamp/S03-smart-contracts/M4-design-patterns/L7-upgradable-contracts/"},next:{title:"Optimizing Gas",permalink:"/educationdao.xyz/docs/courses/blockchain-developer-bootcamp/S03-smart-contracts/M4-design-patterns/L9-optimizing-gas/"}},c={},d=[{value:"Additional Material",id:"additional-material",level:2}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"additional-material-upgradable-contracts",children:"Additional Material: Upgradable Contracts"}),"\n",(0,n.jsx)(t.p,{children:'We wanted to provide another example of an upgradable contract pattern. This pattern uses a separate contract to act as storage to another contract that contains the logic, also known as a "proxy delegate pattern". When you upgrade a contract, all your state is still in the old contract address. Therefore, we say the contract has "Eternal Storage."'}),"\n",(0,n.jsxs)(t.p,{children:["To avoid upgrades to the storage contract it should be as flexible as possible, by using several mappings for each data type where hashes are used as keys (only ",(0,n.jsx)(t.code,{children:"uint"})," is shown in the example below):"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:"address owner = msg.sender;\naddress latestVersion;\nmapping(bytes32 => uint) uIntStorage;\n\nfunction upgradeVersion(address _newVersion) public {    \n  require(msg.sender == owner);    \n  latestVersion = _newVersion;\n}\n\nfunction getUint(bytes32 _key) external view returns(uint) {    \n  return uIntStorage[_key];\n}\n\nfunction setUint(bytes32 _key, uint _value) external {    \n  require(msg.sender == latestVersion);    \n  uIntStorage[_key] = _value;\n}\n\nfunction deleteUint(bytes32 _key) external {    \n  require(msg.sender == latestVersion);    \n  delete uIntStorage[_key];\n}    \n"})}),"\n",(0,n.jsx)(t.p,{children:'Each mapping should be manipulated by three functions: store, retrieve and delete. Use the access control pattern to allow only the most recent version of the logic contract to use the "eternal storage."'}),"\n",(0,n.jsx)(t.h2,{id:"additional-material",children:"Additional Material"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://blog.indorse.io/ethereum-upgradeable-smart-contract-strategies-456350d0557c",children:"Article Series: Summary of Ethereum Upgradeable Smart Contract R&D, Part I"})," and  ",(0,n.jsx)(t.a,{href:"https://medium.com/coinmonks/summary-of-ethereum-upgradeable-smart-contract-r-d-part-2-2020-db141af915a0",children:"Part II"})," Great overview of upgradability patterns."]}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://trufflesuite.com/guides/upgrading-security/",children:"Tutorial: Security considerations and how to upgrade with Open Zeppelin"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"https://ethereum-contract-security-techniques-and-tips.readthedocs.io/en/latest/software_engineering/#upgrading-broken-contracts",children:"Tutorial: Upgrading Broken Contracts (ConsenSys)"})}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.a,{href:"https://dev.to/mudgen/ethereum-s-maximum-contract-size-limit-is-solved-with-the-diamond-standard-2189",children:"Tutorial: Diamond Standard"})," An interesting variation on upgradability patterns. We don't see it out a lot in the wild, but an interesting development!"]}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},8453:(e,t,a)=>{a.d(t,{R:()=>s,x:()=>i});var n=a(6540);const r={},o=n.createContext(r);function s(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);