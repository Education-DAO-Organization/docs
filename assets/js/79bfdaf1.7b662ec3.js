"use strict";(self.webpackChunkeducation_docs=self.webpackChunkeducation_docs||[]).push([[589],{4409:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>c,toc:()=>l});var s=t(4848),o=t(8453);const r={},a="Access Control Design Patterns",c={id:"courses/blockchain-developer-bootcamp/S03-smart-contracts/M4-design-patterns/L5-access-control/index",title:"Access Control Design Patterns",description:"Access Control is a broad term. Most generally, it means who is allowed to do what on your smart contract. Who is allowed to mint new tokens, create a new pointer contract or release funds, for example.",source:"@site/docs/courses/blockchain-developer-bootcamp/S03-smart-contracts/M4-design-patterns/L5-access-control/index.md",sourceDirName:"courses/blockchain-developer-bootcamp/S03-smart-contracts/M4-design-patterns/L5-access-control",slug:"/courses/blockchain-developer-bootcamp/S03-smart-contracts/M4-design-patterns/L5-access-control/",permalink:"/educationdao.xyz/docs/courses/blockchain-developer-bootcamp/S03-smart-contracts/M4-design-patterns/L5-access-control/",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"oliver renwick",lastUpdatedAt:1721055769e3,frontMatter:{},sidebar:"docSidebar",previous:{title:"Oracles",permalink:"/educationdao.xyz/docs/courses/blockchain-developer-bootcamp/S03-smart-contracts/M4-design-patterns/L4-oracles/"},next:{title:"General Finance: Multi-Sig",permalink:"/educationdao.xyz/docs/courses/blockchain-developer-bootcamp/S03-smart-contracts/M4-design-patterns/L6-general-finance/"}},i={},l=[{value:"Restricting Access and <code>Ownable</code>",id:"restricting-access-and-ownable",level:2},{value:"Pausable",id:"pausable",level:2},{value:"Role-Based Access Control",id:"role-based-access-control",level:2},{value:"Additional Resources",id:"additional-resources",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"access-control-design-patterns",children:"Access Control Design Patterns"}),"\n",(0,s.jsx)(n.p,{children:"Access Control is a broad term. Most generally, it means who is allowed to do what on your smart contract. Who is allowed to mint new tokens, create a new pointer contract or release funds, for example."}),"\n",(0,s.jsxs)(n.p,{children:["We'll be looking at Access Control from a Solidity and coding standpoint, but Access Control is actually a pivot point where the blockchain enters the real world. In the following examples, we'll write code to allow a certain ",(0,s.jsx)(n.code,{children:"address"})," to do (or not do) a certain action. However, ",(0,s.jsx)(n.code,{children:"address"})," may correspond to a user in the real world, granting them certain privileges over the contract. If that contract holds the funds for a group, that person is now the treasurer of the group!"]}),"\n",(0,s.jsx)(n.p,{children:"Keep this in mind as we go through these different examples and a teaser for our later sections on DAOs."}),"\n",(0,s.jsxs)(n.h2,{id:"restricting-access-and-ownable",children:["Restricting Access and ",(0,s.jsx)(n.code,{children:"Ownable"})]}),"\n",(0,s.jsxs)(n.p,{children:["A very simple form of access control is making contract state private. You cannot prevent people or computer programs from reading your contracts\u2019 state. The state is publicly available information for anyone with access to the blockchain. However, you ",(0,s.jsx)(n.em,{children:"can"})," restrict other contracts\u2019 access to the state by making state variables private, like in the basic example below:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"contract C1 {  \n  uint private internalNum;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This simple typing can provide some aspect of security through access control."}),"\n",(0,s.jsxs)(n.p,{children:["A broader form of access control is the ",(0,s.jsx)(n.code,{children:"Ownable"}),' design pattern, the "Hello, World!" of access control, you might say. It designates a certain address, or addresses, as the "owner" or admin of the contract.']}),"\n",(0,s.jsx)(n.p,{children:"As we learned earlier, function modifiers allow us to reuse code and increase contract readability. We can also use them to restrict access based on the Ownable model:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'address owner;  \n\nconstructor() payable public {      \n  owner = msg.sender;  \n}    \n\nmodifier onlyOwner() {      \n  require(msg.sender == owner, "Not authorized.");      \n  _;  \n}    \n\nfunction withdraw(uint _amount) onlyOwner public {      \n  owner.transfer(_amount);  \n}      \n'})}),"\n",(0,s.jsxs)(n.p,{children:["The above code declares the variable ",(0,s.jsx)(n.code,{children:"owner"})," and assigns that role to whoever is creating the contract, using the ",(0,s.jsx)(n.code,{children:"msg.sender"})," global variable. We then declare a modifier ",(0,s.jsx)(n.code,{children:"onlyOwner()"}),", which establishes a security check at the top of each function we assign it. Using the modifier syntax, we require a check of the identity of the transaction sender to see if it matches the declared ",(0,s.jsx)(n.code,{children:"owner"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["We then place this modifier in front of whichever functions we want to restrict access to. In this case, we're adding it to the ",(0,s.jsx)(n.code,{children:"withdraw()"})," function (which makes sense, as we don't want anyone to be able to drain our contract of value!). This makes it so that the only user who can access this specific function is ",(0,s.jsx)(n.code,{children:"owner"}),", all other addresses will fail."]}),"\n",(0,s.jsxs)(n.p,{children:["A common contract used for this is OpenZeppelin's ",(0,s.jsx)(n.a,{href:"https://docs.openzeppelin.com/contracts/2.x/api/ownership#Ownable",children:"Ownable.sol"}),", which also lets you ",(0,s.jsx)(n.code,{children:"transferOwnership"})," to another user or ",(0,s.jsx)(n.code,{children:"renounceOwnership"})," if your contract only requires central authority for a certain period of time."]}),"\n",(0,s.jsx)(n.p,{children:"Please note that the Ownable pattern is a bit fragile: it can become a single point of failure and is not very sophisticated in terms of Access Control."}),"\n",(0,s.jsx)(n.h2,{id:"pausable",children:"Pausable"}),"\n",(0,s.jsxs)(n.p,{children:["Another form of access control has to do with turning the smart contract itself into a state machine. As we mentioned earlier in the distributed consensus section, ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Finite-state_machine",children:"a state machine"})," can be in one of a finite number of states at any time."]}),"\n",(0,s.jsxs)(n.p,{children:["To make the smart contract a state machine, we'll use the ",(0,s.jsx)(n.code,{children:"enum"})," variable type to create a series of possible states. To have access control, we'll then assign only certain functions to run when the contract is in a certain state. Here's what this looks like in Solidity, where the possible states are ",(0,s.jsx)(n.code,{children:"Deposits"})," and ",(0,s.jsx)(n.code,{children:"Withdraws"})," and the state changes after a time of 30 days from the contract's ",(0,s.jsx)(n.code,{children:"creationTime"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"enum Stages { Deposits, Withdraws }  \nStages stage = Stages.Deposits;  \nmapping(address => uint) balances;  \nuint creationTime = now;  \n\nfunction deposit() payable public {      \n  require(stage == Stages.Deposits && msg.value > 0);      \n  balances[msg.sender] += msg.value;  \n}        \n\nfunction withdraw() public {      \n  if(stage != Stages.Withdraws && now >= creationTime + 30 days) {          \n    stage = Stages.Withdraws;      \n  }      \n  require(stage == Stages.Withdraws && balances[msg.sender] > 0);      \n  uint amount = balances[msg.sender];      \n  balances[msg.sender] = 0;      \n  msg.sender.transfer(amount);  \n}        \n"})}),"\n",(0,s.jsxs)(n.p,{children:["The deposit() function can only be called when the ",(0,s.jsx)(n.code,{children:"stage"})," enum is in ",(0,s.jsx)(n.code,{children:"Deposits"}),". After 30 days has passed, the contract transitions into ",(0,s.jsx)(n.code,{children:"Withdraws"})," whenever someone calls ",(0,s.jsx)(n.code,{children:"withdraw()"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["For an example of this example, ",(0,s.jsx)(n.a,{href:"https://github.com/blockchainsllc/DAO",children:'"The DAO"'})," contract required 27 days between a successful request to split the DAO and the ability to do so. This ensured the funds were kept within the contract, increasing the likelihood of recovery."]}),"\n",(0,s.jsx)(n.p,{children:"We have another example of this form of access control with the Circuit Breaker design pattern, also called Emergency Stop or Pausable. Circuit Breakers are design patterns that allow contract functionality to be stopped. This would be desirable in situations where there is a live contract where a bug has been detected. Freezing the contract would be beneficial for reducing harm before a fix can be implemented. Here's what it looks like in Solidity:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"contract CircuitBreaker {    \n  bool public stopped = false;    \n  \n  modifier stopInEmergency { require(!stopped); _; }    \n  modifier onlyInEmergency { require(stopped); _; }    \n  function deposit() stopInEmergency public { \u2026 }    \n  function withdraw() onlyInEmergency public { \u2026 }   \n}      \n"})}),"\n",(0,s.jsx)(n.p,{children:"Circuit breaker contracts can be set up to permit certain functions in certain situations. For example, if you are implementing a withdrawal pattern, you might want to stop people from depositing funds into the contract if a bug has been detected, while still allowing accounts with balances to withdraw their funds. In a situation such as this, you would also want to restrict access to the accounts that can modify the stopped state variable, maybe to the contract owner (such as multisig wallet) or a set of admins."}),"\n",(0,s.jsx)(n.p,{children:"Here's another example, with three separate states that dictate certain rules to be followed:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"bool isStopped = false;\naddress owner;\nconstructor() payable public {    \n  owner = msg.sender;\n}\n\nfunction stopContract() public {    \n  require(msg.sender == owner);    \n  isStopped = true;\n}\n\nfunction resumeContract() public {    \n  require(msg.sender == owner)    \n  isStopped = false;\n}\n\nfunction emergencyWithdraw() public {    \n  require(msg.sender == owner && isStopped);    \n  owner.transfer(this.balance);\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"role-based-access-control",children:"Role-Based Access Control"}),"\n",(0,s.jsx)(n.p,{children:"Role-based access control is a more layered approach to access control to meet the more varied demands of a smart contract or application. It follows a similar trend in software development access: Certain individuals are administrators, others are contributors, others can just view the code."}),"\n",(0,s.jsxs)(n.p,{children:["OpenZeppelin advocates using their role-based access control library, ",(0,s.jsx)(n.code,{children:"[Roles.sol,](https://docs.openzeppelin.com/contracts/2.x/api/access#Roles)"})," instead of ",(0,s.jsx)(n.code,{children:"Ownable.sol"}),". They've also implemented roles-based access control in contracts, such as ERC20Mintable.sol, which has a ",(0,s.jsx)(n.code,{children:"MinterRole"})," allowed to create new tokens. You can read more about their approach to role-based access control ",(0,s.jsx)(n.a,{href:"https://docs.openzeppelin.com/contracts/2.x/access-control",children:"in this post here."})]}),"\n",(0,s.jsx)(n.p,{children:"Role-based access control can be critical to developing code-based governance, such as in a DAO. Keep this design pattern in mind when we discuss DAOs later!"}),"\n",(0,s.jsx)(n.h2,{id:"additional-resources",children:"Additional Resources"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://docs.openzeppelin.com/contracts/2.x/access-control",children:"Wiki: Access Control"})," A comprehensive article from OpenZeppelin about Access Control design patterns and how contracts in their repository enacts different patterns."]}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://docs.openzeppelin.com/contracts/2.x/api/ownership#Ownable",children:"Code: OpenZeppelin's Ownable.sol"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b0cf6fbb7a70f31527f36579ad644e1cf12fdf4e/contracts/security/Pausable.sol",children:"Code: OpenZeppelin's Pausable.sol"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>c});var s=t(6540);const o={},r=s.createContext(o);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);