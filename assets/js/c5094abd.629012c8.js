"use strict";(self.webpackChunkeducation_docs=self.webpackChunkeducation_docs||[]).push([[1069],{3807:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var a=n(4848),i=n(8453);const s={},r="General Finance: Multi-Sig",o={id:"courses/blockchain-developer-bootcamp/S03-smart-contracts/M4-design-patterns/L6-general-finance/index",title:"General Finance: Multi-Sig",description:'This section is a tutorial setting up a Multi-Sig contract, which functions as a store of value (it\'s called a "wallet" in the traditional sense of something that holds money, not a crypto-wallet like MetaMask). It is based on this project by Nate Rush.',source:"@site/docs/courses/blockchain-developer-bootcamp/S03-smart-contracts/M4-design-patterns/L6-general-finance/index.md",sourceDirName:"courses/blockchain-developer-bootcamp/S03-smart-contracts/M4-design-patterns/L6-general-finance",slug:"/courses/blockchain-developer-bootcamp/S03-smart-contracts/M4-design-patterns/L6-general-finance/",permalink:"/educationdao.xyz/docs/courses/blockchain-developer-bootcamp/S03-smart-contracts/M4-design-patterns/L6-general-finance/",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"oliver renwick",lastUpdatedAt:1721055769e3,frontMatter:{},sidebar:"docSidebar",previous:{title:"Access Control Design Patterns",permalink:"/educationdao.xyz/docs/courses/blockchain-developer-bootcamp/S03-smart-contracts/M4-design-patterns/L5-access-control/"},next:{title:"index",permalink:"/educationdao.xyz/docs/courses/blockchain-developer-bootcamp/S03-smart-contracts/M4-design-patterns/L7-upgradable-contracts/"}},c={},l=[{value:"What is a Multi-signature wallet?",id:"what-is-a-multi-signature-wallet",level:2},{value:"Project Setup",id:"project-setup",level:2},{value:"Implementing the Contract",id:"implementing-the-contract",level:2},{value:"Constructor",id:"constructor",level:2},{value:"Submit Transaction",id:"submit-transaction",level:2},{value:"Add Transaction",id:"add-transaction",level:2},{value:"Confirm Transaction",id:"confirm-transaction",level:2},{value:"Execute Transaction",id:"execute-transaction",level:2},{value:"Additional Functions",id:"additional-functions",level:2},{value:"Interacting with the Contract",id:"interacting-with-the-contract",level:2}];function d(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"general-finance-multi-sig",children:"General Finance: Multi-Sig"}),"\n",(0,a.jsxs)(t.p,{children:['This section is a tutorial setting up a Multi-Sig contract, which functions as a store of value (it\'s called a "wallet" in the traditional sense of something that holds money, not a crypto-wallet like MetaMask). It is based on ',(0,a.jsx)(t.a,{href:"https://github.com/ConsenSys-Academy/multisig-wallet-exercise/blob/master/Multisig_wallet_info.md",children:"this project"})," by Nate Rush."]}),"\n",(0,a.jsxs)(t.p,{children:["The solution is based on ",(0,a.jsx)(t.a,{href:"https://github.com/ConsenSys/MultiSigWallet",children:"this MultiSignature Wallet"})," found in the ConsenSys github repository."]}),"\n",(0,a.jsxs)(t.p,{children:["You can find the GitHub repository for this exercise ",(0,a.jsx)(t.a,{href:"https://github.com/ConsenSys-Academy/multisig-wallet-exercise",children:"here"}),"."]}),"\n",(0,a.jsx)(t.h2,{id:"what-is-a-multi-signature-wallet",children:"What is a Multi-signature wallet?"}),"\n",(0,a.jsxs)(t.p,{children:["A multi-signature wallet is an account that requires some ",(0,a.jsx)(t.a,{href:"https://www.sunflower-cissp.com/glossary/cissp/3455/m-of-n-control",children:"m-of-n quorum"})," of approved private keys to approve a transaction before it is executed."]}),"\n",(0,a.jsx)(t.p,{children:'In Ethereum, multi-signature wallets are implemented as a smart contract, where each of the approved external accounts sends a transaction to in order to "sign" a group transaction.'}),"\n",(0,a.jsx)(t.p,{children:"Following this project spec designed by the UPenn Blockchain Club, you will now create your own multisignature wallet contract."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsxs)(t.strong,{children:["Note: While it is useful to know how to create a multisignature wallet, if you ever want to use one for real world applications with real funds, make sure you use a far more deeply audited one such as the ",(0,a.jsx)(t.a,{href:"https://gnosis-safe.io/",children:"Gnosis multisignature wallet."})]})}),"\n",(0,a.jsx)(t.h2,{id:"project-setup",children:"Project Setup"}),"\n",(0,a.jsxs)(t.p,{children:["Clone this GitHub repository. The ",(0,a.jsx)(t.a,{href:"https://github.com/ConsenSys-Academy/multisig-wallet-exercise/blob/master/contracts/MultiSignatureWallet.sol",children:"MultiSignatureWallet.sol"})," file in the contracts directory has the structure of a multisignature wallet that you will be implementing."]}),"\n",(0,a.jsx)(t.h2,{id:"implementing-the-contract",children:"Implementing the Contract"}),"\n",(0,a.jsx)(t.p,{children:"Copy the contents of the MultiSignatureWallet.sol file found in the project directory into Remix, Truffle, or whatever smart contract IDE you prefer."}),"\n",(0,a.jsx)(t.p,{children:"Let's review what this contract needs to be able to do before we start writing the code:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["The contract will have ",(0,a.jsx)(t.strong,{children:"multiple owners"})," who will determine which transactions the contract is allowed to execute."]}),"\n",(0,a.jsxs)(t.li,{children:["Contract owners need to be able to ",(0,a.jsx)(t.strong,{children:"propose transactions"})," that other owners can either ",(0,a.jsx)(t.strong,{children:"confirm"})," or ",(0,a.jsx)(t.strong,{children:"revoke"}),"."]}),"\n",(0,a.jsx)(t.li,{children:"If a proposed transaction receives enough support, it will be executed."}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Keeping these requirements in mind, let's go through the contract stub and start implementing this functionality."}),"\n",(0,a.jsx)(t.h2,{id:"constructor",children:"Constructor"}),"\n",(0,a.jsx)(t.p,{children:"Starting with the constructor, you can see that with the latest solidity compiler version, using the contract name as the constructor name has been deprecated, so let's change it to constructor."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"constructor(address[] memory _owners, uint _required)  \n"})}),"\n",(0,a.jsx)(t.p,{children:"We need to check the user inputs to the constructor to make sure that a user does not require more confirmations than there are owners, that the contract requires at least one confirmation before sending a transaction and that the owner array contains at least one address."}),"\n",(0,a.jsx)(t.p,{children:"We can create a modifier that checks these conditions"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"modifier validRequirement(uint ownerCount, uint _required) {          \n  if (   _required > ownerCount || _required == 0 || ownerCount == 0)              \n    revert();          \n  _;      \n}  \n"})}),"\n",(0,a.jsx)(t.p,{children:"And call it when the constructor runs."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"constructor(address[] memory _owners, uint _required) public               \n  validRequirement(_owners.length, _required){...}  \n"})}),"\n",(0,a.jsxs)(t.p,{children:["We are going to want to keep the ",(0,a.jsx)(t.code,{children:"_owners"})," and ",(0,a.jsx)(t.code,{children:"_required"})," values for the life of the contract, so we need to declare the variables in storage in order to save them."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"address[] public owners;      \nuint public required;      \nmapping (address => bool) public isOwner;  \n"})}),"\n",(0,a.jsx)(t.p,{children:"We also added a mapping of owner addresses to booleans so that we can quickly reference (without having to loop over the owners array) whether a specific address is an owner or not."}),"\n",(0,a.jsx)(t.p,{children:"All of these variables will be set in the constructor."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"constructor(address[] memory _owners, uint _required) public           \n  validRequirement(_owners.length, _required)   \n{          \n  for (uint i=0; i<_owners.length; i++) {              \n    isOwner[_owners[i]] = true;          \n  }          \n  owners = _owners;          \n  required = _required;      \n}  \n"})}),"\n",(0,a.jsx)(t.h2,{id:"submit-transaction",children:"Submit Transaction"}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"submitTransaction"})," function allows an owner to submit and confirm a transaction."]}),"\n",(0,a.jsx)(t.p,{children:"First we need to restrict this function to only be callable by an owner."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"require(isOwner[msg.sender]);  \n"})}),"\n",(0,a.jsxs)(t.p,{children:["Looking at the rest of the contract stub, you will notice that there are two other functions in the contract that can help you implement this function, one is called ",(0,a.jsx)(t.code,{children:"addTransaction"})," that takes the same inputs as ",(0,a.jsx)(t.code,{children:"submitTransaction"})," and returns a ",(0,a.jsx)(t.code,{children:"uint transactionId"}),". The other is called ",(0,a.jsx)(t.code,{children:"confirmTransaction"})," that takes a ",(0,a.jsx)(t.code,{children:"uint transactionId"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["We can easily implement ",(0,a.jsx)(t.code,{children:"submitTransaction"})," with the help of these other functions:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"function submitTransaction(address destination, uint value, bytes memory data)           \n  public returns (uint transactionId)       \n{          \n  require(isOwner[msg.sender]);          \n  transactionId = addTransaction(destination, value, data);          \n  confirmTransaction(transactionId);      \n}  \n"})}),"\n",(0,a.jsx)(t.h2,{id:"add-transaction",children:"Add Transaction"}),"\n",(0,a.jsxs)(t.p,{children:["Let's jump to the ",(0,a.jsx)(t.code,{children:"addTransaction"})," function and implement that. This function adds a new transaction to the transaction mapping (which we are about to create), if the transaction does not exist yet."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"function addTransaction(address destination, uint value, bytes memory data) \n  internal \n  returns (uint transactionId);  \n"})}),"\n",(0,a.jsx)(t.p,{children:"A transaction is a data structure that is defined in the contract stub."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"struct Transaction {          \n  address destination;          \n  uint value;          \n  bytes data;          \n  bool executed;      \n}  \n"})}),"\n",(0,a.jsxs)(t.p,{children:["We need to store the inputs to the ",(0,a.jsx)(t.code,{children:"addTransaction"})," function in a Transaction struct and create a transaction id for the transaction. Let's create two more storage variables to keep track of the transaction IDs and transaction mapping."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"uint public transactionCount;      \nmapping (uint => Transaction) public transactions;  \n"})}),"\n",(0,a.jsxs)(t.p,{children:["In the ",(0,a.jsx)(t.code,{children:"addTransaction"})," function we can get the transaction count, store the transaction in the mapping and increment the count. This function modifies the state so it is a good practice to emit an event."]}),"\n",(0,a.jsxs)(t.p,{children:["We will emit a ",(0,a.jsx)(t.code,{children:"Submission"})," event that takes a ",(0,a.jsx)(t.code,{children:"transactionId"}),". Let's define the event first. Events are usually defined at the top of a Solidity contract, so that is what we will do. Add this line just below the contract declaration."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"event Submission(uint indexed transactionId);  \n"})}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.em,{children:(0,a.jsx)(t.strong,{children:"indexed"})})," keyword in the event declaration makes the event easily searchable and is useful when building user interfaces that need to parse lots of events."]}),"\n",(0,a.jsx)(t.p,{children:"In the function body we can call the event."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"function addTransaction(address destination, uint value, bytes memory data)          \n  internal          \n  returns (uint transactionId)      \n{          \n  transactionId = transactionCount;          \n  transactions[transactionId] = Transaction({              \n    destination: destination,              \n    value: value,              \n    data: data,              \n    executed: false          \n  });          \n  transactionCount += 1;          \n  emit Submission(transactionId);      \n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"uint transactionId"})," is returned from the ",(0,a.jsx)(t.code,{children:"addTransaction"})," function to hand over to the ",(0,a.jsx)(t.code,{children:"confirmTransaction"})," function."]}),"\n",(0,a.jsx)(t.h2,{id:"confirm-transaction",children:"Confirm Transaction"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"function confirmTransaction(uint transactionId) public {}  \n"})}),"\n",(0,a.jsx)(t.p,{children:"The confirm transaction function allows an owner to confirm an added transaction."}),"\n",(0,a.jsx)(t.p,{children:"This requires another storage variable, a confirmations mapping that stores a mapping of boolean values at owner addresses. This variable keeps track of which owner addresses has confirmed which transactions."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"mapping (uint => mapping (address => bool)) public confirmations;  \n"})}),"\n",(0,a.jsxs)(t.p,{children:["There are several checks that we will want to verify before we execute this transaction. First, only wallet owners should be able to call this function. Second, we will want to verify that a transaction exists at the specified ",(0,a.jsx)(t.code,{children:"transactionId"}),". Last, we want to verify that the ",(0,a.jsx)(t.code,{children:"msg.sender"})," has not already confirmed this transaction."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"require(isOwner[msg.sender]);      \nrequire(transactions[transactionId].destination != address(0));      \nrequire(confirmations[transactionId][msg.sender] == false);  \n"})}),"\n",(0,a.jsx)(t.p,{children:"Once the transaction receives the required number of confirmations, the transaction should execute, so once the appropriate boolean is set to true"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"confirmations[transactionId][msg.sender] = true;  \n"})}),"\n",(0,a.jsxs)(t.p,{children:["Since we are modifying the state in this function, it is a good practice to log an event. First, we define the event called ",(0,a.jsx)(t.code,{children:"Confirmation"})," that logs the confirmers address as well as the ",(0,a.jsx)(t.code,{children:"transactionId"})," of the transaction that they are confirming."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"event Confirmation(address indexed sender, uint indexed transactionId);  \n"})}),"\n",(0,a.jsx)(t.p,{children:"Both of these event parameters are indexed to make the event more easily searchable. Now we can call the event in the function."}),"\n",(0,a.jsx)(t.p,{children:"After logging the event we can attempt to execute the transaction"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"executeTransaction(transactionId);  \n"})}),"\n",(0,a.jsx)(t.p,{children:"So the entire function should look like this:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"\nfunction confirmTransaction(uint transactionId) public      \n{          \n  require(isOwner[msg.sender]);          \n  require(transactions[transactionId].destination != address(0));          \n  require(confirmations[transactionId][msg.sender] == false);          \n  confirmations[transactionId][msg.sender] = true;          \n  emit Confirmation(msg.sender, transactionId);          \n  executeTransaction(transactionId);      \n}  \n"})}),"\n",(0,a.jsx)(t.h2,{id:"execute-transaction",children:"Execute Transaction"}),"\n",(0,a.jsxs)(t.p,{children:["The execute transaction function takes a single parameter, the ",(0,a.jsx)(t.code,{children:"transactionId"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"First, we want to make sure that the Transaction at the specified id has not already been executed."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"require(transactions[transactionId].executed == false);  \n"})}),"\n",(0,a.jsx)(t.p,{children:"Then we want to verify that the transaction has at least the required number of confirmations."}),"\n",(0,a.jsx)(t.p,{children:"To do this we will loop over the owners array and count how many of the owners have confirmed the transaction. If the count reaches the required amount, we can stop counting (save gas) and just say the requirement has been reached."}),"\n",(0,a.jsxs)(t.p,{children:["Now define a helper function isConfirmed, which we can call from the ",(0,a.jsx)(t.code,{children:"executeTransaction"})," function."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"function isConfirmed(uint transactionId)          \n  public          \n  view          \n  returns (bool)      \n{          \n  uint count = 0;          \n  for (uint i=0; i<owners.length; i++) {              \n    if (confirmations[transactionId][owners[i]])\n      count += 1;              \n    if (count == required)                  \n      return true;          \n  }      \n}  \n"})}),"\n",(0,a.jsxs)(t.p,{children:["It will return true if the transaction is confirmed, so in the ",(0,a.jsx)(t.code,{children:"executeTransaction"})," function, we can execute the transaction if it is confirmed, otherwise do not execute it and then update the Transaction struct to reflect the state."]}),"\n",(0,a.jsx)(t.p,{children:"We are updating the state, so we should log an event reflecting the change."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"event Execution(uint indexed transactionId);      \nevent ExecutionFailure(uint indexed transactionId);  \n"})}),"\n",(0,a.jsx)(t.p,{children:"We have two possible outcomes of this function -- the transaction is not guaranteed to successfully execute. We will want to catalog whether the send transaction successfully executes or fails. Notice how the function body handles a failed transaction and tracks it in the contract state."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:'function executeTransaction(uint transactionId) public      \n{          \n  require(transactions[transactionId].executed == false);          \n  if (isConfirmed(transactionId)) {              \n    // using the "storage" keyword makes "t" a pointer to storage\n    Transaction storage t = transactions[transactionId];                 \n    t.executed = true;              \n    (bool success, bytes memory returnedData) = t.destination.call.value(t.value)(t.data);              \n    if (success)                  \n      emit Execution(transactionId);              \n    else {                  \n      emit ExecutionFailure(transactionId);                  \n      t.executed = false;              \n    }          \n  }      \n}  \n'})}),"\n",(0,a.jsx)(t.h2,{id:"additional-functions",children:"Additional Functions"}),"\n",(0,a.jsx)(t.p,{children:"So far, we have only covered the core functionality of this MultiSignature Wallet found in the ConsenSys github repository."}),"\n",(0,a.jsx)(t.p,{children:"I will leave it to you to continue the exercise and explore the rest of the contract. The code is well commented and you should be able to determine and explain the purpose of each function in the contract."}),"\n",(0,a.jsxs)(t.p,{children:["If you would like a further challenge, continue on to the bottom of the Solidity file and investigate the ",(0,a.jsx)(t.a,{href:"https://github.com/ConsenSys/MultiSigWallet/blob/master/MultiSigWalletWithDailyLimit.sol",children:"MultiSigWalletWithDailyLimit contract"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"Note: If you want to execute a transaction that sends value from the MultiSig contract, you have to make sure that the contract has enough value to make the transfer. You can deposit ether directly to the MultiSig wallet contract using the included fallback function.\xa0"}),"\n",(0,a.jsx)(t.h2,{id:"interacting-with-the-contract",children:"Interacting with the Contract"}),"\n",(0,a.jsx)(t.p,{children:"Now that we have a basic MultiSignature Wallet, let's interact with it and see how it works."}),"\n",(0,a.jsx)(t.p,{children:"Copy the contract that we developed in Remix into the truffle project directory provided."}),"\n",(0,a.jsx)(t.p,{children:"You can see that the project directory comes with a SimpleStorage.sol contract. This is the contract that we are going to be calling from the Multisig contract."}),"\n",(0,a.jsx)(t.p,{children:"If you look in the migrations directory you will see the deployment script that truffle will use to deploy the SimpleStorage contract as well as the MultiSig Wallet."}),"\n",(0,a.jsx)(t.p,{children:"The truffle deployer allows us to access accounts, which is useful given that the MultiSig contract constructor requires an array of owner addresses as as well as the number of required confirmations to execute a transaction."}),"\n",(0,a.jsx)(t.p,{children:"The owners array and the deployment scripts are already in the file."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"const owners = [accounts[0], accounts[1]]\ndeployer.deploy(MultiSig, owners, 2)  \n"})}),"\n",(0,a.jsx)(t.p,{children:"We are only going to require 2 confirmations for the sake of simplicity."}),"\n",(0,a.jsxs)(t.p,{children:["To deploy the contracts, start the development environment by running ",(0,a.jsx)(t.code,{children:"truffle develop"})," in a terminal window at the project directory. The truffle command line will appear"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"truffle(develop)>  \n"})}),"\n",(0,a.jsx)(t.p,{children:"Deploy the contracts"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"truffle(develop)> migrate  \n"})}),"\n",(0,a.jsxs)(t.p,{children:["If ",(0,a.jsx)(t.code,{children:"migrate"})," does not work, try ",(0,a.jsx)(t.code,{children:"migrate --reset"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"And then get the deployed instances of the SimpleStorage.sol and MultiSignatureWallet.sol contracts."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"truffle(develop)> var ss = await SimpleStorage.at(SimpleStorage.address)  \ntruffle(develop)> var ms = await MultiSignatureWallet.at(MultiSignatureWallet.address)  \n"})}),"\n",(0,a.jsx)(t.p,{children:"Check the state of the SimpleStorage contract"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"truffle(develop)> ss.storedData.call()  \n<BN: 0>  \n"})}),"\n",(0,a.jsx)(t.p,{children:"This means that it is 0. You can verify by waiting for the promise to resolve and converting the answer to a string. Try it with:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"ss.storedData.call().then(res => { console.log( res.toString(10) )} )  \n0  \n"})}),"\n",(0,a.jsxs)(t.p,{children:["Let's submit a transaction to update the state of the SimpleStorage contract to the MultiSig contract. ",(0,a.jsx)(t.code,{children:"SumbitTransaction"})," takes the address of the destination contract, the value to send with the transaction and the transaction data, which includes the encoded function signature and input parameters."]}),"\n",(0,a.jsx)(t.p,{children:"If we want to update the SimpleStorage contract data to be 5, the encoded function signature and input parameters would look like this:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"var encoded = '0x60fe47b10000000000000000000000000000000000000000000000000000000000000005'  \n"})}),"\n",(0,a.jsx)(t.p,{children:"Let's get the available accounts and then make a call to the MultiSig contract:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"truffle(develop)> var accounts = await web3.eth.getAccounts()  \ntruffle(develop)> ms.submitTransaction(ss.address, 0, encoded, {from: accounts[0]})  \n"})}),"\n",(0,a.jsx)(t.p,{children:"And we see the transaction information printed in the terminal window. In the logs, we can see that a \u201cSubmission\u201d event was fired, as well as a \u201cConfirmation\u201d event, which is what we expect."}),"\n",(0,a.jsxs)(t.p,{children:["The current state of the MultiSig has one transaction that has not been executed and has one confirmation (from the address that submitted it). One more confirmation should cause the transaction to execute. Let's use the second account to confirm it. The ",(0,a.jsx)(t.code,{children:"confirmTransaction"})," function takes one input, the index of the Transaction to confirm."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"truffle(develop)> ms.confirmTransaction(0, {from: accounts[1]})  \n"})}),"\n",(0,a.jsx)(t.p,{children:"The transaction information is printed in the terminal. You should see two log events this time as well. A \u201cConfirmation\u201d event as well as an \u201cExecution\u201d event. This indicates that the call to SimpleStorage executed successfully. If it didn't execute successfully, we would see an \u201cExecutionFailure\u201d event there instead."}),"\n",(0,a.jsx)(t.p,{children:"We can verify that the state of the contract was updated by running"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"truffle(develop)> ss.storedData.call()  <BN: 5>  \n"})}),"\n",(0,a.jsxs)(t.p,{children:["The ",(0,a.jsx)(t.code,{children:"storedData"})," is now 5. And we can check that the address that updated the SimpleStorage contract was the MultiSig Wallet."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-solidity",children:"truffle(develop)> ss.caller.call()  \u20180x855d1c79ad3fb086d516554dc7187e3fdfc1c79a'  \ntruffle(develop)> ms.address  \u20180x855d1c79ad3fb086d516554dc7187e3fdfc1c79a'  \n"})}),"\n",(0,a.jsx)(t.p,{children:"The two addresses are the same!"}),"\n",(0,a.jsx)(t.p,{children:"Congratulations! You've just built a multi-sig wallet that uses basic access control!"})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var a=n(6540);const i={},s=a.createContext(i);function r(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);