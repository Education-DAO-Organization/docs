"use strict";(self.webpackChunkeducation_docs=self.webpackChunkeducation_docs||[]).push([[7592],{8266:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>l,frontMatter:()=>a,metadata:()=>c,toc:()=>d});var r=t(4848),i=t(8453);const a={},s="Generating Ethereum accounts in JavaScript",c={id:"courses/blockchain-developer-bootcamp/S02-ethereum/M2-accounts/L2-generating-accounts/index",title:"Generating Ethereum accounts in JavaScript",description:"Public key cryptography and digital signatures are a foundational technology that enable blockchains to work. In this project you are going to get your hands dirty and understand how they work at the code level. You will be using JavaScript and a simple web interface to see what is going on.",source:"@site/docs/courses/blockchain-developer-bootcamp/S02-ethereum/M2-accounts/L2-generating-accounts/index.md",sourceDirName:"courses/blockchain-developer-bootcamp/S02-ethereum/M2-accounts/L2-generating-accounts",slug:"/courses/blockchain-developer-bootcamp/S02-ethereum/M2-accounts/L2-generating-accounts/",permalink:"/educationdao.xyz/docs/courses/blockchain-developer-bootcamp/S02-ethereum/M2-accounts/L2-generating-accounts/",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"oliver renwick",lastUpdatedAt:1721137902e3,frontMatter:{},sidebar:"docSidebar",previous:{title:"index",permalink:"/educationdao.xyz/docs/courses/blockchain-developer-bootcamp/S02-ethereum/M2-accounts/L1-accounts/"},next:{title:"index",permalink:"/educationdao.xyz/docs/courses/blockchain-developer-bootcamp/S02-ethereum/M2-accounts/L3-nodes/"}},o={},d=[{value:"Generate Private Key",id:"generate-private-key",level:2},{value:"Generate a Public / Private Keypair",id:"generate-a-public--private-keypair",level:2},{value:"Derive the Ethereum Address From the Keypair",id:"derive-the-ethereum-address-from-the-keypair",level:2},{value:"Creating a Digital Signature With Your Key",id:"creating-a-digital-signature-with-your-key",level:2},{value:"Additional links:",id:"additional-links",level:2}];function h(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"generating-ethereum-accounts-in-javascript",children:"Generating Ethereum accounts in JavaScript"}),"\n",(0,r.jsx)(n.p,{children:"Public key cryptography and digital signatures are a foundational technology that enable blockchains to work. In this project you are going to get your hands dirty and understand how they work at the code level. You will be using JavaScript and a simple web interface to see what is going on."}),"\n",(0,r.jsxs)(n.p,{children:["For a refresher on keys, see ",(0,r.jsx)(n.a,{href:"/educationdao.xyz/docs/courses/blockchain-developer-bootcamp/S01-fundamentals/M1-cryptography/L1-pub-key-crypto/",children:"Public/Private Key Crypto"})," and the ",(0,r.jsx)(n.a,{href:"/educationdao.xyz/docs/courses/blockchain-developer-bootcamp/S01-fundamentals/M1-cryptography/L2-pub-key-crypto-additional/",children:"additional resources"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"generate-private-key",children:"Generate Private Key"}),"\n",(0,r.jsxs)(n.p,{children:["First, we are going to generate a private key, derive public keys from the private key and determine the associated accounts. To get started ",(0,r.jsx)(n.a,{href:"https://github.com/ConsenSys-Academy/ethereum-address-generator-js",children:"clone the project"})," and run:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"$ npm install\n$ npm audit fix --force # this will patch any vulnerabilities in outdated packages\n$ npm run watch # this will watch for updates in main.js and update bundle.js`\n\n# In a separate terminal/shell window in the root of the project\n$ npm run reload # this will serve the app @ localhost:8081 and refresh the page when there are updates\n"})}),"\n",(0,r.jsxs)(n.p,{children:["If you run into any problems while implementing this demo application, try opening the developer tools in the browser (Ctrl + Shift + I or F12) and checking the 'Console' tab. If content doesn't refresh, terminate and restart both terminal calls (",(0,r.jsx)(n.code,{children:"npm run watch"})," and ",(0,r.jsx)(n.code,{children:"npm run reload"}),")"]}),"\n",(0,r.jsxs)(n.p,{children:["In the main.js file include the ",(0,r.jsx)(n.a,{href:"https://www.npmjs.com/package/bip39",children:"bip39 package"}),". We will use this to generate random input to generate a private key."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:'const BIP39 = require("bip39")'})," and directly below that include:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"// Generate a random mnemonic (uses crypto.randomBytes under the hood), defaults to 128-bits of entropy  \nfunction generateMnemonic(){  \n  return BIP39.generateMnemonic()  \n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Note: Not all strings of characters are valid mneomics for generating keys. You can check if a mnemonic is valid by running:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'var isValid = BIP39.validateMnemonic("Enter your mnemonic here")  \n// This will return false because "Enter your mneomnic here" is not a valid phrase\n'})}),"\n",(0,r.jsxs)(n.p,{children:["With this mnemonic, you can generate a seed from which to generate a private key. Add the following line to ",(0,r.jsx)(n.code,{children:"main.js"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"    function generateSeed(mnemonic){      \n      return BIP39.mnemonicToSeed(mnemonic)    \n    }  \n"})}),"\n",(0,r.jsx)(n.h2,{id:"generate-a-public--private-keypair",children:"Generate a Public / Private Keypair"}),"\n",(0,r.jsx)(n.p,{children:"Using this mnemonic as a source of randomness, you can now create signing keypair."}),"\n",(0,r.jsxs)(n.p,{children:["To generate a private key from the hex seed, we will to use the ",(0,r.jsx)(n.a,{href:"https://github.com/ethereumjs/ethereumjs-wallet",children:"ethereumjs-wallet library"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'const hdkey = require("ethereumjs-wallet/hdkey")  \n'})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.em,{children:(0,r.jsxs)(n.strong,{children:["Explore a much more robust address derivation application at ",(0,r.jsx)(n.a,{href:"https://iancoleman.io/bip39/",children:"iancoleman.io"})]})})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"function generatePrivKey(mnemonic){  \n\xa0 \xa0 const seed = generateSeed(mnemonic)  \n\xa0 \xa0 return hdkey.fromMasterSeed(seed).derivePath(`m/44'/60'/0'/0/0`).getWallet().getPrivateKey()  \n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["With the private key, we can generate the public key. Import the ",(0,r.jsx)(n.code,{children:"ethereumjs"})," wallet and derive the public key"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"const Wallet = require('ethereumjs-wallet')    \n  ...        \n  function derivePubKey(privKey){        \n    const wallet = Wallet.fromPrivateKey(privKey)            \n    return wallet.getPublicKey()    \n  }\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Generating the private key and public key is the same for both Bitcoin and Ethereum as both use ",(0,r.jsx)(n.a,{href:"https://en.bitcoin.it/wiki/Secp256k1",children:"secp256k1 elliptic curve cryptography"}),". Deriving an account address from the public key differs slightly."]}),"\n",(0,r.jsx)(n.h2,{id:"derive-the-ethereum-address-from-the-keypair",children:"Derive the Ethereum Address From the Keypair"}),"\n",(0,r.jsx)(n.p,{children:"Deriving an Ethereum address from a public key requires an additional hashing algorithm. Import it like so:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"const keccak256 = require('js-sha3').keccak256;\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Taking the ",(0,r.jsx)(n.code,{children:"keccak-256"})," hash of the public key will return 32 bytes which you need to trim down to the last 20 bytes (40 characters in hex) to get the address"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'function deriveEthAddress(pubKey){    \n  const address = keccak256(pubKey) // keccak256 hash of  publicKey    \n  // Get the last 20 bytes of the public key    \n  return "0x" + address.substring(address.length - 40, address.length)    \n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["You can check this mnemonic, private key and address against ",(0,r.jsx)(n.a,{href:"https://www.myetherwallet.com/#view-wallet-info",children:"myetherwallet"}),". Select restore from mnemonic or private key and verify that the derived address matches the one in this app."]}),"\n",(0,r.jsx)(n.h2,{id:"creating-a-digital-signature-with-your-key",children:"Creating a Digital Signature With Your Key"}),"\n",(0,r.jsx)(n.p,{children:"Using this private key we can sign transactions from this address and broadcast them to the network."}),"\n",(0,r.jsx)(n.p,{children:"Note: There are now two types of transactions"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Legacy (Pre-EIP1559) which at some point will be deprecated"}),"\n",(0,r.jsx)(n.li,{children:"EIP1559 Transactions utilising the new gas fee estimation methods"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Both types are covered here."}),"\n",(0,r.jsx)(n.p,{children:"Nodes that are verifying transactions in the network will use the signature to determine the address of the signatory, cryptographically verifying that every transaction from this account is coming from someone who has access to the corresponding private key."}),"\n",(0,r.jsxs)(n.p,{children:["You can sign transactions in the browser with the ",(0,r.jsx)(n.a,{href:"https://github.com/ethereumjs/ethereumjs-monorepo/tree/master/packages/tx",children:"@ethereumjs/tx library"}),"."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'const EthereumTx = require(\'ethereumjs-tx\')    \n...  \n\nconst { FeeMarketEIP1559Transaction, Transaction } = require("@ethereumjs/tx");\nconst { Chain, Hardfork, Common } = require("@ethereumjs/common");\nconst { bigIntToHex } = require("@ethereumjs/util");\n\nfunction signLegacyTx(privKey, txData){  \n    const txParams = new Common({ chain: Chain.Mainnet, hardfork: Hardfork.Istanbul })\n    const tx = Transaction.fromTxData(txData, { txParams })\n    return tx.sign(privKey)\n}\n\nfunction signEIP1559Tx(privKey, txData){  \n    const txOptions = new Common({ chain: Chain.Mainnet, hardfork: Hardfork.London })\n    const tx = FeeMarketEIP1559Transaction.fromTxData(txData, { txOptions })\n    return tx.sign(privKey)\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Unsigned Ethereum transactions look something like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:"{  \n  nonce: '0x00',  \n  gasPrice: '0x09184e72a000',  \n  gasLimit: '0x2710',  \n  to: '0x31c1c0fec59ceb9cbe6ec474c31c1dc5b66555b6',   \n  value: '0x10',   \n  data: '0x7f7465737432000000000000000000000000000000000000000000000000000000600057',  \n  chainId: 3\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"And a signed transaction looks something like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:"{   \n  nonce: '0x00',   \n  gasPrice: '0x09184e72a000',   \n  gasLimit: '0x2710',   \n  to: '0x31c1c0fec59ceb9cbe6ec474c31c1dc5b66555b6',   \n  value: '0x00',   \n  data: '0x7f7465737432000000000000000000000000000000000000000000000000000000600057',   \n  v: '0x29',   \n  r: '0xb934fbdb16fda944ddc0cb33e64344b90fbd25564444832f7f8d697512069402',  \n  s: '0x29' \n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Notice the main difference between signed and unsigned transactions is the inclusion of the variables ",(0,r.jsx)(n.code,{children:"v"}),", ",(0,r.jsx)(n.code,{children:"r"})," and ",(0,r.jsx)(n.code,{children:"s"}),". These variables are used to recover the address corresponding to the key that signed the transaction. This signed transaction is broadcast to the network to be included in a block. You can read more about these variables in ",(0,r.jsx)(n.a,{href:"https://medium.com/mycrypto/the-magic-of-digital-signatures-on-ethereum-98fe184dc9c7",children:"this excellent article here."})]}),"\n",(0,r.jsx)(n.p,{children:"You can recover the sender address from the signed transaction with the following method:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"function getSignerAddress(signedTx){  \n  return \"0x\" + signedTx.getSenderAddress().toString('hex')\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Unsigned EIP1559 Ethereum transactions looks something like this - ",(0,r.jsx)(n.em,{children:"note"})," the ",(0,r.jsx)(n.code,{children:"gasPrice"})," is missing and replaced with ",(0,r.jsx)(n.code,{children:"maxPriorityFeePerGas"})," and ",(0,r.jsx)(n.code,{children:"maxFeePerGas"}),", and there is a ",(0,r.jsx)(n.code,{children:"type: 2"})," indicating the EIP1559 transaction."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"{\n    nonce: '0x00', \n    type: 2, \n    gasLimit: '0x09184e72a000', \n    maxPriorityFeePerGas: '0x09184e72a000', \n    maxFeePerGas: '0x09184e72a000',\n    gasLimit: '0x2710',\n    to: '0x31c1c0fec59ceb9cbe6ec474c31c1dc5b66555b6', \n    value: '0x10', \n    data: '0x7f7465737432000000000000000000000000000000000000000000000000000000600057',\n    chainId: 3\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"And a signed EIP1559 transaction looks something like this"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"{ \n    nonce: '0x00', \n    type: 2, \n    gasLimit: '0x09184e72a000',\n    maxPriorityFeePerGas: '0x09184e72a000', \n    maxFeePerGas: '0x09184e72a000',\n    to: '0x31c1c0fec59ceb9cbe6ec474c31c1dc5b66555b6', \n    value: '0x00', \n    data: '0x7f7465737432000000000000000000000000000000000000000000000000000000600057', \n    chainId: 3, \n    v: 0x29, \n    r: 0x0172f576ab20d1616ec839b0a8a3475e8113f83f7d98cbe3822f4f4dd7bca262, \n    s: 0x025d92c8f2d3add278c263030fb2b4195bb15ad55418141c774354a9594be972   \n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Notice the main difference between signed and unsigned transaction is the inclusion of the variables ",(0,r.jsx)(n.code,{children:"v"}),", ",(0,r.jsx)(n.code,{children:"r"})," and ",(0,r.jsx)(n.code,{children:"s"}),". These variables are used to recover the address corresponding to the key that signed the transaction."]}),"\n",(0,r.jsxs)(n.p,{children:["That's it! You've successfully generated a private, public keypair and then used that to derive a valid Ethereum address. You've also then created the world's tiniest crypto-wallet. Using the ",(0,r.jsx)(n.code,{children:"signLegacyTx()"})," and the ",(0,r.jsx)(n.code,{children:"signEIP1559Tx()"})," functions you have created and signed transactions. You can now also recover the address from a digital signature or signed transaction."]}),"\n",(0,r.jsx)(n.p,{children:"You'll very rarely have to do this kind of crypto-primitive handling. For one, it's garbage for security. But, also, there is so much tooling available to you to do these kind of operations safely and efficiently at scale. For learning purposes, however, nothing beats coding this stuff on its own!"}),"\n",(0,r.jsx)(n.h2,{id:"additional-links",children:"Additional links:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://etherworld.co/2017/11/17/understanding-the-concept-of-private-key-public-key-and-address-in-ethereum-blockchain/",children:"Understanding the concept of private keys, public keys and addresses in Ethereum"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://en.bitcoin.it/wiki/Secp256k1",children:"Bitcoin wiki on Secp256k1"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://ethereum.github.io/yellowpaper/paper.pdf",children:"Ethereum yellow paper"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://medium.com/mycrypto/the-magic-of-digital-signatures-on-ethereum-98fe184dc9c7",children:"Article: The Magic of Digital Signatures (MyCrypto)"})}),"\n"]}),"\n"]})]})}function l(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>c});var r=t(6540);const i={},a=r.createContext(i);function s(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);