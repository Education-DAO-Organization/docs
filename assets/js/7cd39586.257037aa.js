"use strict";(self.webpackChunkeducation_docs=self.webpackChunkeducation_docs||[]).push([[3462],{6281:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>r,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>a,toc:()=>l});var n=o(4848),c=o(8453);const i={},s=void 0,a={id:"courses/blockchain-developer-bootcamp/S03-smart-contracts/M2-solidity/L3-functions/index",title:"index",description:"Please note that as of Solidity 0.6.0, fallback functions must be explicitly called and have been divided into two:",source:"@site/docs/courses/blockchain-developer-bootcamp/S03-smart-contracts/M2-solidity/L3-functions/index.md",sourceDirName:"courses/blockchain-developer-bootcamp/S03-smart-contracts/M2-solidity/L3-functions",slug:"/courses/blockchain-developer-bootcamp/S03-smart-contracts/M2-solidity/L3-functions/",permalink:"/educationdao.xyz/docs/courses/blockchain-developer-bootcamp/S03-smart-contracts/M2-solidity/L3-functions/",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"oliver renwick",lastUpdatedAt:1721137902e3,frontMatter:{},sidebar:"docSidebar",previous:{title:"index",permalink:"/educationdao.xyz/docs/courses/blockchain-developer-bootcamp/S03-smart-contracts/M2-solidity/L2-data-type-and-variables/"},next:{title:"index",permalink:"/educationdao.xyz/docs/courses/blockchain-developer-bootcamp/S03-smart-contracts/M2-solidity/L4-storage-and-memory/"}},r={},l=[];function d(e){const t={code:"code",li:"li",ol:"ol",p:"p",strong:"strong",...(0,c.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Please note that as of Solidity 0.6.0, fallback functions must be explicitly called and have been divided into two:"})}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.code,{children:"[fallback()](https://docs.soliditylang.org/en/latest/contracts.html#fallback-function)"})}),"\xa0called when no other function matches (if the receive ether function does not exist then this includes calls with empty call data). You can make this function\xa0",(0,n.jsx)(t.code,{children:"payable"}),"\xa0or not. If it is not\xa0",(0,n.jsx)(t.code,{children:"payable"}),"\xa0then transactions not matching any other function which send value will revert. You should only need to implement the new fallback function if you are following an upgrade or proxy pattern."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.code,{children:"[receive()](https://docs.soliditylang.org/en/latest/contracts.html#receive-ether-function)"})}),"\xa0called whenever the call data is empty (whether or not ether is received). This function is implicitly\xa0",(0,n.jsx)(t.code,{children:"payable"}),"."]}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,c.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},8453:(e,t,o)=>{o.d(t,{R:()=>s,x:()=>a});var n=o(6540);const c={},i=n.createContext(c);function s(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:s(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);