"use strict";(self.webpackChunkeducation_docs=self.webpackChunkeducation_docs||[]).push([[5936],{5324:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>r,default:()=>l,frontMatter:()=>s,metadata:()=>d,toc:()=>a});var o=t(4848),c=t(8453);const s={},r="Ethereum .on Events",d={id:"courses/blockchain-developer-bootcamp/S04-developer-tooling/M7-web3-frontend/L3-ethereum-on-events/index",title:"Ethereum .on Events",description:"Open in CodeSandbox",source:"@site/docs/courses/blockchain-developer-bootcamp/S04-developer-tooling/M7-web3-frontend/L3-ethereum-on-events/index.md",sourceDirName:"courses/blockchain-developer-bootcamp/S04-developer-tooling/M7-web3-frontend/L3-ethereum-on-events",slug:"/courses/blockchain-developer-bootcamp/S04-developer-tooling/M7-web3-frontend/L3-ethereum-on-events/",permalink:"/educationdao.xyz/docs/courses/blockchain-developer-bootcamp/S04-developer-tooling/M7-web3-frontend/L3-ethereum-on-events/",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"oliver renwick",lastUpdatedAt:1721061896e3,frontMatter:{},sidebar:"docSidebar",previous:{title:"A Demystification of \u201cConnect Wallet\u201d",permalink:"/educationdao.xyz/docs/courses/blockchain-developer-bootcamp/S04-developer-tooling/M7-web3-frontend/L2-demystifying-connect-wallet/"},next:{title:"Persisting Connectivity in Web3 with useEffect",permalink:"/educationdao.xyz/docs/courses/blockchain-developer-bootcamp/S04-developer-tooling/M7-web3-frontend/L3-persisting-connectivity/"}},i={},a=[{value:"How To Build",id:"how-to-build",level:2},{value:"Where does <code>useInjectedProvider</code> come from?",id:"where-does-useinjectedprovider-come-from",level:2},{value:"Firing off Events",id:"firing-off-events",level:2}];function h(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,c.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"ethereum-on-events",children:"Ethereum .on Events"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.a,{href:"https://codesandbox.io/s/0x1-ethereum-on-events-start-qbhl91",children:(0,o.jsx)(n.img,{src:"https://img.shields.io/badge/Open%20in-CodeSandbox-blue?style=forthebadge-square&logo=codesandbox",alt:"Open in CodeSandbox"})})}),"\n",(0,o.jsxs)(n.p,{children:["So\u2026 million dollar question: How does a user disconnect? It has to happen through MetaMask or whichever browser wallet they use. All they need to do is open MetaMask and click ",(0,o.jsx)(n.code,{children:"Disconnect"}),". And just like that, they\u2019ve revoked permissions that they initially granted to that dApp."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"disconnect-flow.png",src:t(6066).A+"",width:"5912",height:"2301"})}),"\n",(0,o.jsx)("blockquote",{children:(0,o.jsx)(n.p,{children:"\u26d3\ufe0f We\u2019re not logging in and out of a dApp, we\u2019re simply granting and revoking permissions with MetaMask, and the dApp frontend needs to reflect that after the fact. But notice how there\u2019s a louder call to action to \u2018Connect\u2019 than there is to \u2018Disconnect\u2019?"})}),"\n",(0,o.jsx)(n.p,{children:"If your user disconnects, the frontend, by default, remains unaffected\u2014 but that\u2019s not what should happen. If they\u2019re revoking permissions, the frontend should know to purge what information is held in the dApp state, like their balances or current account activity."}),"\n",(0,o.jsxs)(n.p,{children:["Under the hood, when your user disconnects, their browser wallet emits an event. This happens for a few other actions they could take like switching their account, or what network they\u2019re on. With these events, comes the ",(0,o.jsx)(n.code,{children:".on"})," function, an event listener, that can handle those events and then execute logic based on what just happened. It takes the argument of an event as a string, so disconnecting would be one for example, and a callback function, which will dictate what logic should be executed next."]}),"\n",(0,o.jsxs)(n.p,{children:["For an event like disconnecting, the Ethereum Provider API ",(0,o.jsx)(n.a,{href:"https://docs.metamask.io/guide/ethereum-provider.html#disconnect",children:"documentation"})," explains that:"]}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:["Once\xa0",(0,o.jsx)(n.code,{children:"disconnect"}),"has been emitted, the provider will not accept any new requests until the connection to the chain has been re-established, which requires reloading the page."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"As a precaution, MetaMask's Ethereum Provider API documentation also strongly suggests reloading the browser when the network is changed."}),"\n",(0,o.jsxs)(n.p,{children:["Looking back on the ",(0,o.jsx)(n.a,{href:"https://codesandbox.io/s/0x0-metamask-connect-finish-0fkbhj",children:"CodeSandbox"})," example from the last lesson, on load, the ",(0,o.jsx)(n.code,{children:"useEffect"})," will fire off on every refresh. On disconnect, nothing will change. On a ",(0,o.jsx)(n.em,{children:(0,o.jsx)(n.strong,{children:"refresh"})})," after a disconnect, only then will the \u2018Connect\u2019 button will show up."]}),"\n",(0,o.jsxs)(n.p,{children:["Switching the account or the network would yield similar results. The ",(0,o.jsx)(n.code,{children:"<Account />"})," component would still render\u2014 so long as you didn\u2019t disconnect. On refresh, it would grab the account you just connected with. If your user is on a network where a target smart contract is not deployed, they won\u2019t be able to execute any contract functionality, because it doesn\u2019t exist on that network. ",(0,o.jsx)(n.em,{children:(0,o.jsx)(n.a,{href:"https://blog.ethereum.org/2022/06/21/testnet-deprecation",children:"Or what if they\u2019re on a network that is set to be deprecated, like Rinkeby, Kovan, or Ropsten, they won\u2019t be able to execute on-chain functionality reliably."})})," Each of those actions requires an event listener to update the state because they\u2019re not being triggered from the dApp frontend directly, but rather through MetaMask."]}),"\n",(0,o.jsx)(n.h2,{id:"how-to-build",children:"How To Build"}),"\n",(0,o.jsxs)(n.p,{children:["We\u2019re going to start off with a new CodeSandbox project. This one is slightly more advanced than the last one. You\u2019ll recognize a few components like the ",(0,o.jsx)(n.code,{children:"Connect"})," or the ",(0,o.jsx)(n.code,{children:"InstallMetaMask"})," button, or ",(0,o.jsx)(n.code,{children:"Account"}),". There are a few new additions:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"/helpers"}),": The format address function has been moved to its own file here."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"/constants"}),": You\u2019ll find an object containing different network versions and names. Feel free to substitute your own to play around with."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"/hooks"}),": You\u2019ll find ",(0,o.jsx)(n.code,{children:"useInjectedProvider"})," here, where we\u2019ll create our own hook to call the Ethereum Provider API and hold our wallet state. The ",(0,o.jsx)(n.code,{children:"useEffect"})," from the last lesson will live in this file, but it\u2019ll be modified slightly."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"/components"}),": There\u2019s a ",(0,o.jsx)(n.code,{children:"<Network />"})," component here that takes a prop of ",(0,o.jsx)(n.code,{children:"network"}),", and that along with ",(0,o.jsx)(n.code,{children:"<Account />"})," will sit inside of ",(0,o.jsx)(n.code,{children:"<Card />"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Open up ",(0,o.jsx)(n.code,{children:"App.js"}),", and you\u2019ll see a very familiar empty ",(0,o.jsx)(n.code,{children:"<main></main>"})," element. ",(0,o.jsx)(n.code,{children:"ethereum"})," is unpacked from the window, and ",(0,o.jsx)(n.code,{children:"Card"}),", ",(0,o.jsx)(n.code,{children:"Account"}),", and ",(0,o.jsx)(n.code,{children:"Network"})," are imported but commented out."]}),"\n",(0,o.jsxs)(n.p,{children:["At the moment, the ",(0,o.jsx)(n.code,{children:"Connect"})," button doesn\u2019t have any functionality. This will come from the ",(0,o.jsx)(n.code,{children:"useInjectedProvider"})," hook we\u2019ll be building out."]}),"\n",(0,o.jsxs)(n.h2,{id:"where-does-useinjectedprovider-come-from",children:["Where does ",(0,o.jsx)(n.code,{children:"useInjectedProvider"})," come from?"]}),"\n",(0,o.jsx)(n.p,{children:"Custom hooks allow for code reusability, readability, and modularity."}),"\n",(0,o.jsxs)(n.p,{children:["Our provider logic wouldn\u2019t have to live inside ",(0,o.jsx)(n.code,{children:"App.js"})," anymore. The reason for that is as a dApp codebase evolves, so does its state\u2014 to a level of absolute complexity that needs to be maintainable. That doesn\u2019t include the components, the routing, or any unrelated API calls. In order to achieve that, we need to be able to extract that logic and keep it organized. That way anyone looking through your code will be able to know exactly where they can find the logic that handles connectivity and wallet state."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"App.js"})," can then be looked at as the file where our dApp structure will come together, its single purpose will be to import and house the components that need to render based on whatever condition is true at the moment."]}),"\n",(0,o.jsxs)(n.p,{children:["If you open up ",(0,o.jsx)(n.code,{children:"useInjectedProvider"}),", you\u2019ll see ",(0,o.jsx)(n.code,{children:"useEffect"}),", as well as ",(0,o.jsx)(n.code,{children:"useState"}),", has been imported from React. Also being imported is ",(0,o.jsx)(n.code,{children:"NETWORK_NAME"}),", which we\u2019ll be using to hold onto the current network we\u2019re connected to. Then ",(0,o.jsx)(n.code,{children:"useInjectedProvider"})," is defined as a function with a ",(0,o.jsx)(n.code,{children:"useEffect"})," that is empty."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"import { useEffect, useState } from 'react';\n\nimport { NETWORK_NAME } from '../constants/networks';\n\nexport const useInjectedProvider = () => {\n\tuseEffect(() => {}, []);\n\treturn {};\n};\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The first thing we\u2019ll want to do is unpack ",(0,o.jsx)(n.code,{children:"ethereum"})," from ",(0,o.jsx)(n.code,{children:"window"}),". Then we\u2019ll need to use the ",(0,o.jsx)(n.code,{children:"useState"})," hook to hold onto the network name and our connected account like this:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"const { ethereum } = window;\n\nconst [networkName, setNetworkName] = useState('');\nconst [connectedAccount, setConnectedAccount] = useState('');\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The updated ",(0,o.jsx)(n.code,{children:"useInjectedProvider"})," hook should look like this:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"export const useInjectedProvider = () => {\n  const { ethereum } = window;\n\n  const [networkName, setNetworkName] = useState('');\n  const [connectedAccount, setConnectedAccount] = useState('');\n\tuseEffect(() => {}, []);\n\treturn {};\n};\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Following the ",(0,o.jsx)(n.code,{children:"useEffect"})," is a return block, at the moment it\u2019s an empty object, but when we change ",(0,o.jsx)(n.code,{children:"networkName"})," or ",(0,o.jsx)(n.code,{children:"connectedAccount"}),", we\u2019ll want to return that value to be consumed wherever we import this hook."]}),"\n",(0,o.jsx)(n.p,{children:"In the last lesson, we used an asynchronous IIFE to request the accounts that we connected with, and then set the state of the connected account to the account returned."}),"\n",(0,o.jsx)(n.p,{children:"Then, we\u2019ll want to get the network we\u2019re on. We can achieve this by grabbing the chain ID like so:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"const chainId = await ethereum.request({ method: 'eth_chainId' });\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This will give us the hexadecimal string representing the current chain ID. From there, when we want to set ",(0,o.jsx)(n.code,{children:"networkName"})," to the value of ",(0,o.jsx)(n.code,{children:"NETWORK_NAME[chainId]"}),". This is what the async IIFE should look like:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"(async () => {\n  try {\n    const chainId = await ethereum.request({ method: 'eth_chainId' });\n    const [connectedAccount] = await ethereum.request({\n      method: 'eth_accounts',\n    });\n\n    setNetworkName(NETWORK_NAME[chainId]);\n    setConnectedAccount(connectedAccount);\n  } catch (e) {\n    console.log(e);\n  }\n})()\n"})}),"\n",(0,o.jsxs)(n.p,{children:["And that should work. Almost. ",(0,o.jsx)(n.em,{children:"We\u2019re not done here yet."})," We still have to expose those values in state to be consumed by the rest of our dApp. But we also need to define our connect functionality too, fear not, it\u2019s exactly as it was in the last lesson. Because we unpacked ",(0,o.jsx)(n.code,{children:"ethereum"})," from the window inside ",(0,o.jsx)(n.code,{children:"useInjectedProvider"}),", we\u2019re able to use that for our connect function, that we can define right below where we hold ",(0,o.jsx)(n.code,{children:"networkName"})," and ",(0,o.jsx)(n.code,{children:"connectedAccount"})," in state."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"const connectWallet = async () => {\n\t\ttry {\n\t\t\tconst [account] =\n\t\t\t\tawait ethereum.request({ method: 'eth_requestAccounts' })\n\t\t\tsetConnectedAccount(account);\n\t\t} catch (e) {\n\t\t\tconsole.log(e);\n\t\t}\n\t};\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Inside ",(0,o.jsx)(n.code,{children:"return {}"}),", we\u2019ll need to add ",(0,o.jsx)(n.code,{children:"ethereum"}),", ",(0,o.jsx)(n.code,{children:"connectWallet"}),", ",(0,o.jsx)(n.code,{children:"networkName"}),", and ",(0,o.jsx)(n.code,{children:"connectedAccount"}),". ",(0,o.jsx)(n.em,{children:"Almost there."})]}),"\n",(0,o.jsxs)(n.p,{children:["Switch back to ",(0,o.jsx)(n.code,{children:"App.js"}),". Yes, we have our ",(0,o.jsx)(n.code,{children:"InstallMetaMask"})," and ",(0,o.jsx)(n.code,{children:"Connect"}),", but the connect button won\u2019t work \ud83e\udd14. If you open up ",(0,o.jsx)(n.code,{children:"Connect.js"}),", you\u2019ll see it\u2019s expecting the prop of a function, ",(0,o.jsx)(n.code,{children:"connectWallet"}),", to be passed in. Same with ",(0,o.jsx)(n.code,{children:"Account"})," and ",(0,o.jsx)(n.code,{children:"Network"}),"; both of those components are expecting a prop to be passed in\u2014 and we\u2019re already holding onto those in our hook \ud83e\udd14."]}),"\n",(0,o.jsxs)(n.p,{children:["We don\u2019t want this hook to be referenced in every component file. Doing so would result in the async IIFE being called multiple times just to get those values. Instead, what we want is to reference it once in ",(0,o.jsx)(n.code,{children:"App.js"}),", and from there, we can pass in those values as props to the components that are expecting them."]}),"\n",(0,o.jsxs)(n.p,{children:["The way that we can grab those values is by importing ",(0,o.jsx)(n.code,{children:"useInjectedProvider"}),", and unpacking them like this:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"const { ethereum, connectWallet, connectedAccount, networkName } = useInjectedProvider()\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The ternary conditional inside main should feel very familiar here, show the ",(0,o.jsx)(n.code,{children:"InstallMetaMask"})," button if ",(0,o.jsx)(n.code,{children:"ethereum"})," isn\u2019t detected, show the ",(0,o.jsx)(n.code,{children:"Connect"})," button if it is, and if ",(0,o.jsx)(n.code,{children:"connectedAccount"})," is true\u2026 show both ",(0,o.jsx)(n.code,{children:"Account"})," and ",(0,o.jsx)(n.code,{children:"Network"}),"?"]}),"\n",(0,o.jsx)("blockquote",{children:(0,o.jsxs)(n.p,{children:["\u269b\ufe0f ",(0,o.jsx)(n.code,{children:"Account"})," and ",(0,o.jsx)(n.code,{children:"Network"})," are sibling elements that need to be wrapped either by a parent component like ",(0,o.jsx)(n.code,{children:"Card"})," or a fragment."]})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"Card"})," component will wrap around both ",(0,o.jsx)(n.code,{children:"Account"})," and ",(0,o.jsx)(n.code,{children:"Network"})," like this:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"<Card>\n\t<Account account={connectedAccount} />\n\t<Network network={networkName} />\n</Card>\n"})}),"\n",(0,o.jsx)(n.p,{children:"Your updated ternary should look like this:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"{connectedAccount ? (\n\t<Card>\n\t\t<Account account={connectedAccount} />\n\t\t<Network network={networkName} />\n\t</Card>\n) : ethereum ? (\n\t<Connect connectWallet={connectWallet} />\n) : (\n\t<InstallMetaMask />\n)}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"firing-off-events",children:"Firing off Events"}),"\n",(0,o.jsxs)(n.p,{children:["Disconnecting, switching networks or accounts, won\u2019t trigger the changes we\u2019re looking for, just yet. But setting up ",(0,o.jsx)(n.code,{children:"useInjectedProvider"})," the way we did will allow us to do that now."]}),"\n",(0,o.jsxs)(n.p,{children:["Back in ",(0,o.jsx)(n.code,{children:"useInjectedProvider"}),", right beneath where the ",(0,o.jsx)(n.code,{children:"try/catch"})," block, we should have ",(0,o.jsx)(n.code,{children:"ethereum.on()"})," for as many events as we need to listen for. The updated async IIFE should include this:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-jsx",children:"\t\nethereum.on('disconnect', () => {\n\twindow.location.reload();\n});\n\nethereum.on('chainChanged', () => {\n\twindow.location.reload();\n});\n\nethereum.on('accountsChanged', () => {\n\twindow.location.reload();\n});\n"})}),"\n",(0,o.jsx)(n.p,{children:"Try switching your account. Notice the refresh, and how your account updates\u2026 right away? What about network? That too? And disconnect? You should see the connect button, if you don\u2019t have any accounts connected. For a smaller example like this, reloading the window is the bare minimum we should prompt. When reloaded, the hook gets called again as all the components are rendered to the DOM, and we have fresh new state to pass in."})]})}function l(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},6066:(e,n,t)=>{t.d(n,{A:()=>o});const o=t.p+"assets/images/disconnect-flow-7fe51b38b83c32122821fdf2cbe4e023.png"},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>d});var o=t(6540);const c={},s=o.createContext(c);function r(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:r(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);