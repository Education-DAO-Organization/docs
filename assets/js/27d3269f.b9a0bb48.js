"use strict";(self.webpackChunkeducation_docs=self.webpackChunkeducation_docs||[]).push([[9144],{6203:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>d});var o=n(4848),s=n(8453);const a={},i="A Demystification of \u201cConnect Wallet\u201d",r={id:"courses/blockchain-developer-bootcamp/S04-developer-tooling/M7-web3-frontend/L2-demystifying-connect-wallet/index",title:"A Demystification of \u201cConnect Wallet\u201d",description:"Open in CodeSandbox",source:"@site/docs/courses/blockchain-developer-bootcamp/S04-developer-tooling/M7-web3-frontend/L2-demystifying-connect-wallet/index.md",sourceDirName:"courses/blockchain-developer-bootcamp/S04-developer-tooling/M7-web3-frontend/L2-demystifying-connect-wallet",slug:"/courses/blockchain-developer-bootcamp/S04-developer-tooling/M7-web3-frontend/L2-demystifying-connect-wallet/",permalink:"/educationdao.xyz/docs/courses/blockchain-developer-bootcamp/S04-developer-tooling/M7-web3-frontend/L2-demystifying-connect-wallet/",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"oliver renwick",lastUpdatedAt:1721055769e3,frontMatter:{},sidebar:"docSidebar",previous:{title:"Ethereum Provider API",permalink:"/educationdao.xyz/docs/courses/blockchain-developer-bootcamp/S04-developer-tooling/M7-web3-frontend/L1-ethereum-provider-api/"},next:{title:"Ethereum .on Events",permalink:"/educationdao.xyz/docs/courses/blockchain-developer-bootcamp/S04-developer-tooling/M7-web3-frontend/L3-ethereum-on-events/"}},c={},d=[{value:"Onboarding",id:"onboarding",level:2},{value:"How Buidl?",id:"how-buidl",level:2},{value:"State",id:"state",level:3},{value:"Async/Await",id:"asyncawait",level:3},{value:"Showing the account",id:"showing-the-account",level:3},{value:"An externally owned account by any other formatting\u2026 would still be you.",id:"an-externally-owned-account-by-any-other-formatting-would-still-be-you",level:3},{value:"Identicon",id:"identicon",level:3},{value:"You can disconnect, but you can never leave\u2026 Maybe",id:"you-can-disconnect-but-you-can-never-leave-maybe",level:2}];function l(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",img:"img",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{id:"a-demystification-of-connect-wallet",children:"A Demystification of \u201cConnect Wallet\u201d"}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.a,{href:"https://codesandbox.io/s/0x0-metamask-connect-start-8csed1",children:(0,o.jsx)(t.img,{src:"https://img.shields.io/badge/Open%20in-CodeSandbox-blue?style=forthebadge-square&logo=codesandbox",alt:"Open in CodeSandbox"})})}),"\n",(0,o.jsx)(t.p,{children:"We\u2019re going to start out with one of the first things you\u2019ll want to tackle when developing your frontend alpha: The user\u2019s ability to connect their wallet."}),"\n",(0,o.jsxs)(t.p,{children:["This presents Web3 developers with a user experience (UX) quandary because ",(0,o.jsx)(t.a,{href:"https://www.nngroup.com/videos/jakobs-law-internet-ux/",children:"Jakob\u2019s Law of the Internet User Experience"}),"  dictates that people \u201cprefer your site to work the same way as all the other sites they already know.\u201d You\u2019ll know you\u2019re on a Web3-enabled frontend when you see a button in a site\u2019s header prompting you to ",(0,o.jsx)(t.em,{children:"connect"}),". This is the button you\u2019ll be rendering in your dApp if ",(0,o.jsx)(t.code,{children:"window.ethereum"})," was detected. This call to action might come as a shock to your users who are accustomed to input fields for their credentials to log in."]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"https://twitter.com/tommyk_eth/status/1481464394139815937",src:n(8801).A+"",width:"3058",height:"2499"})}),"\n",(0,o.jsxs)(t.p,{children:["You know how, on a traditional website, you can\u2019t take certain actions until you\u2019ve logged in? You need to verify who you are initially. And the logic to log yourself in involves ",(0,o.jsx)(t.code,{children:"fetch()"})," and how that queries a database to confirm if the inputted credentials match the ones stored after some cryptographic black magic, like ",(0,o.jsx)(t.a,{href:"https://auth0.com/blog/adding-salt-to-hashing-a-better-way-to-store-passwords/",children:"salting"}),", has been applied?"]}),"\n",(0,o.jsx)(t.p,{children:"Well, \u201cConnect Wallet\u201d is the equivalent for Web3. You won\u2019t be able to execute writable functionality until you've connected with your wallet. The calls you make to those smart contracts require a sender to initiate and fulfill them. After all, someone has to pay the gas needed for that transaction."}),"\n",(0,o.jsx)(t.p,{children:"When you click \u201cConnect Wallet,\u201d MetaMask will trigger a pop-up asking you to grant that dApp permission to view your accounts, your balances, and your activity, and initiate transactions on your behalf."}),"\n",(0,o.jsxs)(t.p,{children:["The transactions you make will be public, but you can remain pseudonymous. You don\u2019t exchange doxxable information. You\u2019re able to own your data, you never surrender your private key for a database to manage. The wallet proves your identity by proving you own the accounts associated with it because all of your accounts are derived from your seed phrase. Interactions with public blockchains are intended to be permissionless and trustless. ",(0,o.jsx)(t.em,{children:(0,o.jsx)(t.strong,{children:"On Web3, your word is only as good as how much ether you have for gas."})})]}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsxs)(t.p,{children:["\ud83d\udcd5 ",(0,o.jsxs)(t.em,{children:["But what does it ",(0,o.jsx)(t.strong,{children:"actually"})," mean to connect a wallet?"]})," If the pop-up from MetaMask tells you that you\u2019re granting this dApp permission to view publicly available information that is on a WHOLE blockchain for everyone to see, what\u2019s the difference between that and someone viewing your account history on Etherscan? It comes down to trust. You can remain pseudonymous in both cases, yes. However, that person viewing your account history on Etherscan can\u2019t initiate a contract call on your behalf, nor can they suggest one. The idea of permissions here can be reduced to a single question: ",(0,o.jsx)(t.em,{children:"Do I trust this dApp to let me call smart contract functions in a way that is safe for me?"})]}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"onboarding",children:"Onboarding"}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.a,{href:"https://uxdesign.cc/15-rules-of-user-sign-in-experience-ae9011d04ee3",children:"Websites on Web2 require onboarding of their own, but as end users, we don\u2019t pay much mind to it because it\u2019s something we\u2019ve always been used to doing"}),". On Web2, it starts with providing contextual information like our email address, and our names that we enter into input fields. Oh, and our phone numbers too. We play ",(0,o.jsx)(t.a,{href:"https://www.oreilly.com/library/view/regular-expressions-cookbook/9781449327453/ch04s19.html",children:"regex gymnastics"})," to generate secure passwords. These personally identifying tidbits of data are managed by a centralized entity that\u2019ll only interact with us if it knows who we are. Sometimes, however, they need to know too much. ",(0,o.jsx)(t.a,{href:"https://www.notion.so/forbes.com/sites/marketshare/2012/03/05/if-youre-not-paying-for-it-you-become-the-product/?sh=35b534ce5d6e",children:"And we don\u2019t always know how our data is being managed"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["Web3 comes with an onboarding process of its own, but it ",(0,o.jsx)(t.em,{children:"delegates the task of identity management to applied cryptography and the Ethereum blockchain"}),", not just a single database managed by one big tech giant. Instead of your user creating an account from their credentials, they\u2019ll need to have a browser wallet like MetaMask to derive an account from their private key."]}),"\n",(0,o.jsx)(t.p,{children:"When we begin building, we want to assume our user doesn\u2019t have MetaMask installed, therefore the Provider Interface is non-existent, and we can\u2019t execute any Web3 functionalities. So we want to prompt them to install it. If they do have MetaMask installed, we want to offer them the ability to connect. If they approve that request, we want to show the address of the account they\u2019re connected with."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"Connect Wallet Flow",src:n(4384).A+"",width:"1400",height:"870"})}),"\n",(0,o.jsx)(t.h2,{id:"how-buidl",children:"How Buidl?"}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.a,{href:"https://codesandbox.io/s/0x0-metamask-connect-start-8csed1",children:(0,o.jsx)(t.img,{src:"https://img.shields.io/badge/Open%20in-CodeSandbox-blue?style=forthebadge-square&logo=codesandbox",alt:"Open in CodeSandbox"})})}),"\n",(0,o.jsxs)(t.p,{children:["If you take a look at ",(0,o.jsx)(t.code,{children:"[App.js](https://codesandbox.io/s/0x0-metamask-connect-start-8csed1?file=/src/App.js)"}),", you\u2019ll see it\u2019s been purged of the boilerplate that ",(0,o.jsx)(t.code,{children:"yarn create react-app"})," generates. There are styled components and a sprinkle of Framer Motion for animations. But we don\u2019t have any other Web3 dependencies. In the ",(0,o.jsx)(t.code,{children:"/components"})," directory, there are, however, three specifically named components, and they are the only ones you\u2019ll be using for this activity. You won\u2019t need to create anymore."]}),"\n",(0,o.jsx)(t.p,{children:"What is important for us to have is a browser wallet like MetaMask. This is where it all begins."}),"\n",(0,o.jsxs)(t.p,{children:["The first objective here is to ",(0,o.jsx)(t.em,{children:(0,o.jsx)(t.strong,{children:"conditionally render"})})," a button that prompts your user to ",(0,o.jsx)(t.strong,{children:"Install MetaMask"})," if ",(0,o.jsx)(t.code,{children:"window.ethereum"})," does not exist. And we can achieve this using ",(0,o.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator",children:"ternary operators"})," in our JSX. We can then *",(0,o.jsx)(t.a,{href:"https://reactjs.org/docs/introducing-jsx.html#embedding-expressions-in-jsx",children:"embed* JavaScript expressions in our JSX"})," very easily, so long as we wrap the logic in curly braces."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-jsx",children:"<>\n  {condition\n    ? <Element to render if condition is true>\n    : <Element to render if condition is false>\n  }\n</>\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Open up ",(0,o.jsx)(t.code,{children:"App.js"})," and you\u2019ll see the components ",(0,o.jsx)(t.code,{children:"InstallMetaMask"}),", ",(0,o.jsx)(t.code,{children:"ConnectButton"}),", and ",(0,o.jsx)(t.code,{children:"Account"})," are imported, but they\u2019re commented out. Using ternary operators, go inside ",(0,o.jsx)(t.code,{children:"<main></main>"}),", get ",(0,o.jsx)(t.code,{children:"ConnectButton"})," to show up if ",(0,o.jsx)(t.code,{children:"window.ethereum"})," is defined. If it is not defined, render ",(0,o.jsx)(t.code,{children:"InstallMetaMask"}),". Now open the code sandbox in two windows\u2014 one where you have MetaMask installed, and one where you don\u2019t. See how on one browser there\u2019s a call to action to install MetaMask, and the other has a call to action to \u2728 ",(0,o.jsx)(t.em,{children:"Connect"})," \u2728?"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-jsx",children:" <main>\n  {window.ethereum\n    ? <ConnectButton />\n    : <InstallMetaMask />\n  }\n</main>\n"})}),"\n",(0,o.jsx)(t.h3,{id:"state",children:"State"}),"\n",(0,o.jsxs)(t.p,{children:["To get users connecting to your dApp, we\u2019ll need to call the ",(0,o.jsx)(t.code,{children:"[eth_requestAccounts](https://docs.metamask.io/guide/rpc-api.html#restricted-methods)"})," JSON-RPC method from ",(0,o.jsx)(t.code,{children:"window.ethereum"}),". In ",(0,o.jsx)(t.code,{children:"App.js"}),", we\u2019re importing ",(0,o.jsx)(t.code,{children:"useState"})," from React. The ",(0,o.jsx)(t.code,{children:"eth_requestAccounts"})," method returns a promise. When that promise to grab a user\u2019s accounts resolves to an array, we\u2019ll need to hold onto it with the ",(0,o.jsx)(t.a,{href:"https://reactjs.org/docs/hooks-state.html",children:"state hook"}),". ",(0,o.jsx)(t.code,{children:"useState"})," accepts an initial state but returns two values: the current state, and a function to update the state."]}),"\n",(0,o.jsxs)(t.p,{children:["Because our user hasn\u2019t connected yet, our initial state would be an empty string. The first value will be ",(0,o.jsx)(t.code,{children:"account"}),", and the second will be ",(0,o.jsx)(t.code,{children:"setAccount"}),". We can define this hook in ",(0,o.jsx)(t.code,{children:"App.js"}),". When the promise resolves, we get the array, we\u2019ll want to ",(0,o.jsx)(t.em,{children:"hold it in state"}),", which we\u2019ll achieve by calling ",(0,o.jsx)(t.code,{children:"setAccount"}),"."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-jsx",children:"const [account, setAccount] = useState('')\n"})}),"\n",(0,o.jsx)(t.p,{children:"Now that we have that setup, we can \ud83d\udc40 define the function to connect \ud83d\udc40."}),"\n",(0,o.jsx)(t.h3,{id:"asyncawait",children:"Async/Await"}),"\n",(0,o.jsxs)(t.p,{children:["We\u2019ll need to define our function to connect ",(0,o.jsx)(t.a,{href:"https://www.freecodecamp.org/news/synchronous-vs-asynchronous-in-javascript/",children:"asynchronously, rather than synchronously"}),", because of the way functions in JavaScript behave. If ",(0,o.jsx)(t.code,{children:"eth_requestAccounts"})," returns a promise, we\u2019ll want to wait for that promise to resolve before any other action in that function can be executed. We need to wait for our request to be sent to the blockchain through the nodes, then back to us to consume."]}),"\n",(0,o.jsxs)(t.p,{children:["Inside the function body, we can throw in a ",(0,o.jsx)(t.code,{children:"try/catch"})," block. See the code below:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-jsx",children:"const connect = async () => {\n\ttry {\n\t    // eth_requestAccounts\n\t}\n\tcatch (e) {\n\t    console.log(e)\n\t}\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["We can see here the connect function will now ",(0,o.jsx)(t.em,{children:"attempt"})," to ask a user to connect, but anticipate failure. In the event of a failure, ",(0,o.jsx)(t.a,{href:"https://docs.metamask.io/guide/ethereum-provider.html#errors",children:"it will spit out an error code"})," that can then be used to give feedback\u2014 in this case, we can prompt a user to retry connecting. If a user rejects the request to connect, this is where the ",(0,o.jsx)(t.code,{children:"catch"})," will be triggered letting them know that they didn\u2019t approve the request."]}),"\n",(0,o.jsxs)(t.p,{children:["Next step is to create a variable and assign the ",(0,o.jsx)(t.code,{children:"eth_requestAccounts"})," method to it. See the code below:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-jsx",children:"const account = (await window.ethereum.request({ method: 'eth_requestAccounts' })[0]`\n"})}),"\n",(0,o.jsxs)(t.p,{children:["This is where we can tie up our connect functionality. Because we have an ",(0,o.jsx)(t.code,{children:"async"})," function, we\u2019ll get to use the ",(0,o.jsx)(t.code,{children:"await"})," statement on the method we\u2019ll want to wait for. The parentheses around the ",(0,o.jsx)(t.code,{children:"await"})," statement followed by the ",(0,o.jsx)(t.code,{children:"[0]"})," means once this promise is resolved and we get an array, we\u2019ll only want the first account. That\u2019s what our ",(0,o.jsx)(t.code,{children:"accounts"})," variable will return, and that\u2019s what we\u2019ll use the  ",(0,o.jsx)(t.code,{children:"setAccount"}),"  function on."]}),"\n",(0,o.jsx)(t.p,{children:"Your function should look like this:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-jsx",children:'  const connect = async () => {\n    try {\n      const account = (\n        await window.ethereum.request({ method: "eth_requestAccounts" })\n      )[0];\n      setAccount(account);\n    } catch (e) {\n      console.log(e);\n    }\n  };\n'})}),"\n",(0,o.jsxs)(t.p,{children:["Once the function is defined, switch over to ",(0,o.jsx)(t.code,{children:"ConnectButton"}),". As a React functional component, it takes the prop of ",(0,o.jsx)(t.code,{children:"connect"}),". The next place you\u2019ll see ",(0,o.jsx)(t.code,{children:"connect"})," being used in ",(0,o.jsx)(t.code,{children:"ConnectButton"})," is in the return block, in ",(0,o.jsx)(t.code,{children:"<Button>"}),", where it\u2019s being passed into ",(0,o.jsx)(t.code,{children:"handleClick"}),". ",(0,o.jsx)(t.code,{children:"ConnectButton"})," will be expecting the connect function that we can pass into it when we render it in ",(0,o.jsx)(t.code,{children:"<main></main>"})," like so:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-jsx",children:"<ConnectButton connect={connect} />\n"})}),"\n",(0,o.jsx)(t.p,{children:"The updated expression will look like this:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-jsx",children:"// in a server-side framework like Next.js or Vite SSR you might have to do a check to see if window is defined like typeof window !== 'undefined' && window.ethereum\n <main>\n \n  {window.ethereum\n    ? <ConnectButton connect={connect} />\n    : <InstallMetaMask />\n  }\n</main>\n"})}),"\n",(0,o.jsx)(t.h3,{id:"showing-the-account",children:"Showing the account"}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"Gru Connect Wallet Meme",src:n(3774).A+"",width:"1276",height:"788"})}),"\n",(0,o.jsxs)(t.p,{children:["Tried to click connect, connected successfully, and noticed you\u2019re still seeing the connect button? We\u2019re going to have to tweak our logic in the ",(0,o.jsx)(t.code,{children:"<main></main>"})," element to reflect what sorcery we have going on in our app state right now."]}),"\n",(0,o.jsxs)(t.p,{children:["Up until this point, we had a binary condition to check for: if ",(0,o.jsx)(t.code,{children:"window.ethereum"})," was injected into the browser. If you look back on ",(0,o.jsx)(t.code,{children:"account"}),", it initially started as an empty string\u2014 one of the six ",(0,o.jsx)(t.a,{href:"https://freecodecamp.org/news/falsy-values-in-javascript/",children:"falsy values"})," in JavaScript. If a user has connected, it has a value as a 42-character long hexadecimal string. Ternary operators come in handy here because we can chain them (but not much or they get hard to read \ud83d\ude05)."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-jsx",children:"<>\n  {firstCondition\n    ? <Element to render if firstCondition is true>\n    : secondCondition\n\t  ? <Element to render if secondCondition is true>\n\t  : <Element to render if secondCondition is false>\n  }\n</>\n\n"})}),"\n",(0,o.jsxs)(t.p,{children:["The first condition to check for can be ",(0,o.jsx)(t.code,{children:"account"}),". If that is no longer an empty string, then we can render a ",(0,o.jsx)(t.code,{children:"<p>"})," tag with the content of ",(0,o.jsx)(t.code,{children:"account"}),". If it is still an empty string, we can check for ",(0,o.jsx)(t.code,{children:"window.ethereum"}),". Perhaps the user doesn\u2019t have MetaMask installed, and that\u2019s why ",(0,o.jsx)(t.code,{children:"account"})," is an empty string. So we can go show them ",(0,o.jsx)(t.code,{children:"ConnectButton"})," if it was detected, and ",(0,o.jsx)(t.code,{children:"InstallMetaMask"})," if it wasn\u2019t."]}),"\n",(0,o.jsx)(t.p,{children:"Your updated expression should look like this:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-jsx",children:"{account\n  ? <p>{account}</p>\n  : window.ethereum\n  ? <ConnectButton connect={connect} />\n\t: <InstallMetaMask />\n)}\n"})}),"\n",(0,o.jsx)(t.p,{children:"And now you should be able to see your address in its full glory. All 42 characters of it. This is great, but it feels a bit excessive, no?"}),"\n",(0,o.jsx)(t.h3,{id:"an-externally-owned-account-by-any-other-formatting-would-still-be-you",children:"An externally owned account by any other formatting\u2026 would still be you."}),"\n",(0,o.jsx)(t.p,{children:"We\u2019re not displaying embarrassing usernames or email addresses anymore. There\u2019s no longer a limit to how long your username can be. I mean, we\u2019re at 42 WHOLE characters long. Imagine displaying that on a mobile browser \ud83d\ude05. Thanks, but no thanks. As developers architecting a user experience in uncharted territory, we have to ask ourselves if we\u2019re overloading the user cognitively by displaying their address in its entirety."}),"\n",(0,o.jsxs)(t.p,{children:["Consider the ",(0,o.jsx)(t.a,{href:"https://medium.com/@coffeeandjunk/design-psychology-serial-position-effect-ca0e4cf299cb",children:"Serial Position Effect"}),". Looking at your address, try to read out the characters before you lose your position. But you know you connected, if you check MetaMask, you\u2019ll see the first and last few digits are identical. The code you wrote helped connect a user. Is it really necessary to show the whole address? No. Not really. Ideally, you don\u2019t want a user spending too much time confirming that their address on a dApp matches what they know connected with. But you do want to show a portion of their address."]}),"\n",(0,o.jsxs)(t.p,{children:["Before you do anything, in ",(0,o.jsx)(t.code,{children:"<main>"}),", let\u2019s swap the ",(0,o.jsx)(t.code,{children:"<p>{account}</p>"})," for ",(0,o.jsx)(t.code,{children:"<Account account={account} />"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["Now open up ",(0,o.jsx)(t.code,{children:"Account.js"}),". The return block has a ",(0,o.jsx)(t.code,{children:"<Wrap>"})," element, but ",(0,o.jsx)(t.code,{children:"<Blockie />"})," is commented out. Without uncommenting ",(0,o.jsx)(t.code,{children:"<Blockie />"}),", add ",(0,o.jsx)(t.code,{children:"{account}"})," inside ",(0,o.jsx)(t.code,{children:"<Wrap>"}),". You\u2019ll still see the whole address, but we have some styling. So we have that going for us, which is nice. But it doesn\u2019t fix our problem of how to display an address. What we need to do is\u2026 truncate it. Just a smidge. To the first six and last four characters, to be more specific. The first six account for the leading ",(0,o.jsx)(t.code,{children:"0x"}),", which is the hash prefix, plus the next four characters."]}),"\n",(0,o.jsxs)(t.p,{children:["We can define a function called ",(0,o.jsx)(t.code,{children:"formatAddress"})," that takes the argument of a user\u2019s address. Because the address is a string, we can use the ",(0,o.jsxs)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substr",children:[(0,o.jsx)(t.code,{children:"substr()"})," method"]})," to return portions of it. BUT\u2026 we need to separate those portions too. What we\u2019ll return is a ",(0,o.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals",children:"template literal"})," with the first substring, followed by ellipses, and then the second substring."]}),"\n",(0,o.jsx)(t.p,{children:"Your function should look like this:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-jsx",children:"const formatAddress = (addr) => {\n  return `${addr.substr(0, 6)}...${addr.substr(-4)}`;\n};\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Now you can add a ",(0,o.jsx)(t.code,{children:"<p>"})," tag inside ",(0,o.jsx)(t.code,{children:"Wrap"}),", and inside that ",(0,o.jsx)(t.code,{children:"<p>"})," tag, you can add ",(0,o.jsx)(t.code,{children:"{formatAddress(address)}"}),". Looks a lot better, right? But we\u2019re not done yet. There\u2019s something even cooler we can add."]}),"\n",(0,o.jsx)(t.h3,{id:"identicon",children:"Identicon"}),"\n",(0,o.jsxs)(t.p,{children:["If you open up MetaMask and look on the right, you\u2019ll see a little pixelated icon. Depending on your settings, you might be seeing a ",(0,o.jsx)(t.a,{href:"https://www.npmjs.com/package/jazzicon",children:"Jazzicon"})," or a ",(0,o.jsx)(t.a,{href:"https://www.npmjs.com/package/ethereum-blockies",children:"Blockie"}),". If you change accounts on MetaMask, it also changes. That\u2019s because it\u2019s unique to you. It was generated from your address. There can be as many variations of Jazzicons or Blockies as there can be addresses. So now it can be used as a digital representation of your address. When a user sees what their identicon looks like on MetaMask, it would be helpful to see what it would also look like on your dApp as a subtle visual confirmation that they are using the correct account."]}),"\n",(0,o.jsxs)(t.p,{children:["Take a look at ",(0,o.jsx)(t.code,{children:"<Blockie />"}),". Right now it takes the props of ",(0,o.jsx)(t.code,{children:"size"})," and ",(0,o.jsx)(t.code,{children:"scale"}),", but those are just for styling. What we\u2019ll want to pass in is a ",(0,o.jsx)(t.code,{children:"seed"}),", which will determine how our blockie is generated. All we need to do is pass in our address as the seed. Hit save. I know. Cool, right? That simple."]}),"\n",(0,o.jsxs)(t.p,{children:["Here\u2019s what your ",(0,o.jsx)(t.code,{children:"Account.js"})," should look like:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-jsx",children:"const Account = ({ account }) => {\n  const formatAddress = (addr) => {\n    return `${addr.substr(0, 6)}...${addr.substr(-4)}`;\n  };\n\n  return (\n    <Wrap>\n      <Blockies seed={account} size={10} scale={3} />\n      <p>{formatAddress(account)}</p>\n    </Wrap>\n  );\n};\n"})}),"\n",(0,o.jsx)(t.h2,{id:"you-can-disconnect-but-you-can-never-leave-maybe",children:"You can disconnect, but you can never leave\u2026 Maybe"}),"\n",(0,o.jsx)(t.p,{children:"So far, the bases you\u2019ve covered include onboarding a user. Allowing them to connect. And showing that they\u2019ve connected. But what about when they leave your dApp? Go ahead and refresh the page. See how it doesn\u2019t show your address anymore? Now click connect. Notice now how MetaMask didn\u2019t even popup, but your address shows up right away? But wait, get this. Open up MetaMask. We\u2019re still connected?"}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"Screenshot showing MetaMask is still connected",src:n(393).A+"",width:"2976",height:"1494"})}),"\n",(0,o.jsxs)(t.p,{children:["Try connecting to a known dApp. Now refresh. Address still there? Let\u2019s dig around a bit, ",(0,o.jsx)(t.em,{children:"some"})," of these dApps will let you disconnect. Re-read that sentence. Now try to disconnect, if there\u2019s a button for it. You won\u2019t see your address anymore, great. But go check MetaMask. You\u2019re ",(0,o.jsx)(t.strong,{children:"still"})," connected. I know. ",(0,o.jsx)(t.em,{children:"I know."})]}),"\n",(0,o.jsxs)(t.p,{children:["Your users will be expecting a button to log out, it seems only rational. And you have to look them in the eyes, wistfully, and say, no\u2026 no, I\u2019m sorry, things work a bit differently in the wonderland that is Web3. Go look in ",(0,o.jsx)(t.code,{children:"/components"}),", there\u2019s no component for a button to log out. Not only that but your users will remain connected and you have to explain this to them because this is unlike any good experience they ever had on an application before. So what is actually going on?"]}),"\n",(0,o.jsx)(t.p,{children:"Your users are connected until they\u2019re not\u2014 even if they refresh their browser, clear their cache, cookies and browser data. In the next lesson we\u2019ll cover why your user stays connected."})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},393:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/connect-wallet-connectivity-7c12648cde169da39ba77d194c80640b.png"},4384:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/connect-wallet-flow-4d6cacd2074e02a1a958aa621d9b3da3.png"},3774:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/connect-wallet-gru-6651d2ed8a76d658bef039700bd55807.png"},8801:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/connect-wallet-tweet-6edf5bd08472d836a744441ff0ea2274.png"},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>r});var o=n(6540);const s={},a=o.createContext(s);function i(e){const t=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(a.Provider,{value:t},e.children)}}}]);