"use strict";(self.webpackChunkeducation_docs=self.webpackChunkeducation_docs||[]).push([[4209],{5501:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>a,toc:()=>l});var r=n(4848),o=n(8453);const i={},s="Integer Over / Underflow",a={id:"courses/blockchain-developer-bootcamp/S03-smart-contracts/M6-security/L2e-int-under-over-attack/index",title:"Integer Over / Underflow",description:"Note: Due to SafeMath being included in Solidity 0.8.x, the likelihood of you writing an integer under or overflow is extremely unlikely. However, a number of contracts still exist with this attack vector and it's good to know about. But, again, the inclusion of SafeMath helps significantly protect against this attack vector.",source:"@site/docs/courses/blockchain-developer-bootcamp/S03-smart-contracts/M6-security/L2e-int-under-over-attack/index.md",sourceDirName:"courses/blockchain-developer-bootcamp/S03-smart-contracts/M6-security/L2e-int-under-over-attack",slug:"/courses/blockchain-developer-bootcamp/S03-smart-contracts/M6-security/L2e-int-under-over-attack/",permalink:"/educationdao.xyz/docs/courses/blockchain-developer-bootcamp/S03-smart-contracts/M6-security/L2e-int-under-over-attack/",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"oliver renwick",lastUpdatedAt:1721137902e3,frontMatter:{},sidebar:"docSidebar",previous:{title:"Reentrancy Example",permalink:"/educationdao.xyz/docs/courses/blockchain-developer-bootcamp/S03-smart-contracts/M6-security/L2d-reentrancy-attack/"},next:{title:"index",permalink:"/educationdao.xyz/docs/courses/blockchain-developer-bootcamp/S03-smart-contracts/M6-security/L3-sc-checklist/"}},c={},l=[];function u(e){const t={a:"a",code:"code",h1:"h1",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h1,{id:"integer-over--underflow",children:"Integer Over / Underflow"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Note: Due to SafeMath being included in Solidity 0.8.x, the likelihood of you writing an integer under or overflow is extremely unlikely. However, a number of contracts still exist with this attack vector and it's good to know about. But, again, the inclusion of SafeMath helps significantly protect against this attack vector."})}),"\n",(0,r.jsxs)(t.p,{children:["This contract shows what an integer overflow vulnerability (",(0,r.jsx)(t.a,{href:"https://swcregistry.io/docs/SWC-101",children:"SWC-101"}),") looks like."]}),"\n",(0,r.jsx)(t.p,{children:"In this VulnerableContract the lockTime is manipulable by the currentInvestor. The maximum value for the lockTime is 4294967295 because it is declared type uint32 (and 2^32 = 4294967296). If the currentInvestor attempts to set the value above\xa04294967295, it will overflow and start counting back at 0."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"pragma solidity ^0.5.0;\n\n// Example Integer Overflow and Underflow  \n\ncontract VulnerableContract {    \n  uint MINIMUM_INVESTMENT = 50 ether;    \n  uint32 INITIAL_LOCK_TIME = 2592000; // 30 days in seconds    \n  address payable currentInvestor;    \n  uint investmentTimestamp;    \n  uint32 public lockTime = INITIAL_LOCK_TIME;      \n  \n  function  increaseLockTime(uint32 _seconds) public {        \n    require(msg.sender == currentInvestor);        \n    // uint32 max is 4294967295 seconds. Attack passing 4292375295\n    lockTime += _seconds;     \n  }          \n  \n  function invest() public payable {        \n    require(currentInvestor == address(0));        \n    require(msg.value >= MINIMUM_INVESTMENT);        \n    currentInvestor = msg.sender;        \n    investmentTimestamp = now;    \n  }          \n  \n  function withdrawWithProfit() public {        \n    require(msg.sender == currentInvestor);        \n    require(now - investmentTimestamp >= lockTime);        \n    uint profit = 1 ether + lockTime * 1 wei;        \n    currentInvestor.transfer(MINIMUM_INVESTMENT + profit);        \n    currentInvestor = address(0);        \n    lockTime = INITIAL_LOCK_TIME;    \n  }          \n  \n  function getBalance() view public returns(uint) {        \n    return address(this).balance;    \n  }          \n  \n  function() external payable {}\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["This type of attack is easily avoidable by using ",(0,r.jsx)(t.a,{href:"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol",children:"a SafeMath library such as this"}),", that provides safety checks and will revert on error. The SafeMath library ",(0,r.jsx)(t.a,{href:"https://blog.soliditylang.org/2020/12/16/solidity-v0.8.0-release-announcement/",children:"now ships"})," with Solidity as of 0.8.x, so you do not have to include it if you're working with a compiler on 0.8.x except in very specific cases."]})]})}function d(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>a});var r=n(6540);const o={},i=r.createContext(o);function s(e){const t=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);