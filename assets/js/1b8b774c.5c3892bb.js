"use strict";(self.webpackChunkeducation_docs=self.webpackChunkeducation_docs||[]).push([[5257],{3777:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>l});var a=n(4848),s=n(8453);const i={},o="Where Do Smart Contracts Fit in Our Mental Model?",r={id:"courses/blockchain-developer-bootcamp/S03-smart-contracts/M1-mental-model/L1-mental-model-sc/index",title:"Where Do Smart Contracts Fit in Our Mental Model?",description:"In this chapter, we're going to dive deeper into smart contracts: What they are, how they work and how you can build with them safely.",source:"@site/docs/courses/blockchain-developer-bootcamp/S03-smart-contracts/M1-mental-model/L1-mental-model-sc/index.md",sourceDirName:"courses/blockchain-developer-bootcamp/S03-smart-contracts/M1-mental-model/L1-mental-model-sc",slug:"/courses/blockchain-developer-bootcamp/S03-smart-contracts/M1-mental-model/L1-mental-model-sc/",permalink:"/educationdao.xyz/docs/courses/blockchain-developer-bootcamp/S03-smart-contracts/M1-mental-model/L1-mental-model-sc/",draft:!1,unlisted:!1,tags:[],version:"current",lastUpdatedBy:"oliver renwick",lastUpdatedAt:1721055769e3,frontMatter:{},sidebar:"docSidebar",previous:{title:"Install a Full Besu Node using Bonsai Storage on Ubuntu Server",permalink:"/educationdao.xyz/docs/courses/blockchain-developer-bootcamp/S02-ethereum/M6-Installing-besu/"},next:{title:"index",permalink:"/educationdao.xyz/docs/courses/blockchain-developer-bootcamp/S03-smart-contracts/M2-intro-to-truffle/L1-background/"}},c={},l=[{value:"Smart Contract Workflows: Creation and Execution",id:"smart-contract-workflows-creation-and-execution",level:2},{value:"New Development and Security Considerations",id:"new-development-and-security-considerations",level:2},{value:"Additional Material",id:"additional-material",level:2}];function d(e){const t={a:"a",em:"em",h1:"h1",h2:"h2",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"where-do-smart-contracts-fit-in-our-mental-model",children:"Where Do Smart Contracts Fit in Our Mental Model?"}),"\n",(0,a.jsxs)(t.p,{children:["In this chapter, we're going to dive deeper into ",(0,a.jsx)(t.strong,{children:"smart contracts"}),": What they are, how they work and how you can build with them safely."]}),"\n",(0,a.jsxs)(t.p,{children:["First, a general definition. ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Smart_contract",children:"Smart contracts"})," are programs deployed to a blockchain network that automatically execute when triggered by valid transactions. A basic analogy for a smart contract is a vending machine: The customer puts in money, punches in the code of the desired item. Assuming a valid input, the vending machine will release the desired item."]}),"\n",(0,a.jsx)(t.p,{children:"The following properties are desired in any smart contract system:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Trustless"})," Meaning two or more parties can act on an agreement without relying on any intermediary to facilitate the transaction"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Universally Accessible"})," Meaning every participant must be able to access and use the system. They should not have to rely on anyone\u2019s approval to participate in the network."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Traceable"})," Contract transactions should be traceable. Data provenance is critical to resolving disputes and for legal compliance."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Immutable transactions"})," Transactions should be irreversible (atomic). Participants should not be able to revoke their decisions, just as legal contracts are binding, so are smart contracts."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Self executing"})," We want to move as far away from manual implementation as possible and have these contracts be automatic. The extent that the self executing contract is self executing is subject to use case variability."]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"To understand where smart contracts fit into blockchains, let's review the blockchain mental model we constructed in the first chapter."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"mental model of a general blockchain",src:n(8313).A+"",width:"960",height:"540"})}),"\n",(0,a.jsxs)(t.p,{children:["Let's zoom into the ",(0,a.jsx)(t.strong,{children:"Network Interface \u2014 Consensus Protocol \u2014 Network State"})," elements on the lower left corner. We'll also update the names for the Ethereum network:"]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"diagram showing transaction processing in ethereum network",src:n(6723).A+"",width:"576",height:"372"})}),"\n",(0,a.jsx)(t.p,{children:"The Ethereum Virtual Machine (EVM) is a secure execution environment for smart contracts. EVM bytecode is executed on the Ethereum Virtual Machine and the outcome constitutes the new world state. The EVM is Turing-complete, meaning it can execute more advanced code than the Bitcoin network. However, to make sure transactions don't loop forever, transactions on the Ethereum network also have gas limits, as we've discussed."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"ethereum network as a series of state transitions",src:n(1217).A+"",width:"1020",height:"370"})}),"\n",(0,a.jsxs)(t.p,{children:["EVM bytecode is machine code, meaning it's very difficult for humans to read or program in. However, core developers have built higher-order smart contract languages that compile to EVM bytecode. One well-known higher-order smart contract language that compiles down to EVM bytecode is ",(0,a.jsx)(t.strong,{children:"Solidity"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"Here's a diagram showing how Solidity code compiles down into EVM bytecode, which is then deployed to the Ethereum network:"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"diagram showing how solidity compiles to bytecode",src:n(3621).A+"",width:"960",height:"720"})}),"\n",(0,a.jsx)(t.h2,{id:"smart-contract-workflows-creation-and-execution",children:"Smart Contract Workflows: Creation and Execution"}),"\n",(0,a.jsxs)(t.p,{children:["There are two practical types of transactions involving smart contracts: ",(0,a.jsx)(t.strong,{children:"Contract creation"})," and ",(0,a.jsx)(t.strong,{children:"Message call"})," ",(0,a.jsx)(t.img,{alt:"two kinds of contract calls",src:n(6028).A+"",width:"960",height:"720"})]}),"\n",(0,a.jsx)(t.p,{children:"The image below shows the contract creation process. When a smart contract is deployed to the network, the code is initialized and states are created with addresses."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"graphic of contract creation",src:n(4231).A+"",width:"960",height:"720"})}),"\n",(0,a.jsx)(t.p,{children:"Here, we can see the high-level process of the EVM executing a transaction to a smart contract. The transaction includes input data, which is fed into the smart contract bytecode. The outcome of the transaction contributes to the network state change."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"graphic showing a smart contract execution",src:n(2273).A+"",width:"960",height:"720"})}),"\n",(0,a.jsx)(t.p,{children:"Let's look further into how the EVM handles deployed bytecode and contract data when it executes a transaction's EVM bytecode."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"EVM stack architecture",src:n(8146).A+"",width:"960",height:"720"})}),"\n",(0,a.jsx)(t.p,{children:"While there are a lot of elements to this picture, try to keep in mind we are looking at a simple state machine. State is fed into the stack, the EVM processes the stack, and the result is either saved, if it affects the network state, or discarded, if it was only necessary for the transaction execution."}),"\n",(0,a.jsx)(t.p,{children:"The state in the EVM stack is in three areas:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Memory"})," This is ",(0,a.jsx)(t.em,{children:(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Volatile_memory",children:"volatile"})})," memory, meaning that, unless it is explicitly written back into the network state, will only be accessible during the transaction execution."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Storage"})," This is persistent memory taken from the network state. Read and writing to the network state is more expensive, gas-wise, than memory, since it affects the global state of the network."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Stack"})," The information processed by the EVM stack while going through the bytecode. (Stack is a data structure used by all computer processors, you can learn more about it ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Stack_(abstract_data_type)",children:"here"})]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"When the EVM wishes to process a transaction, it first takes the input data, fetches the relevant contract bytecode and any world state account storage data. Then, the EVM processes the transaction data through the stack data type. Last, after the EVM has finished processed the transaction, it takes any world state data altered by the transaction and writes those changes to the world state. The diagram below illustrates this process (note that PC is the Program Counter, essentially keeping track of the steps to measure gas):"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{src:n(2689).A+"",width:"960",height:"720"})}),"\n",(0,a.jsx)(t.p,{children:"The handling of memory and storage in the transaction execution process can be one of the hardest challenges for new developers in the space. We'll go over it more in the Solidity section, but be aware it's a different level of programming than a typical JavaScript or Python developer encounters."}),"\n",(0,a.jsx)(t.h2,{id:"new-development-and-security-considerations",children:"New Development and Security Considerations"}),"\n",(0,a.jsx)(t.p,{children:"The process we've just outlined contains many challenges for developers entering the space, such as:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Smart contracts are immutable"})," They cannot be modified (only re-deployed). A common web development mantra is \u201cmove fast and break things\u201d. This is not advisable in smart contract development due to this immutability."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"High cost of failure"})," Typical software development that is this accessible does not involve potentially losing tremendous financial value. You're more likely to encounter this level of scrutiny and security in hardware and financial services programming."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Smart contracts information is public and anyone can call your public functions"})," Once your code is deployed and particularly if it starts accruing value, it will attract more opportunities for it to be hacked or misused."]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"In this section, we hope to both equip you with the ability to code smart contracts but also protect yourself and anyone interacting with your code. Most of all, we hope to instill in you a healthy sense of paranoia and fear about the code you deploy to public networks. However, we will also show you how to deal with this terror by protecting your code with smart and secure tools."}),"\n",(0,a.jsx)(t.h2,{id:"additional-material",children:"Additional Material"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Smart_contract",children:"Wikipedia: Smart Contracts,"})," ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Stack_(abstract_data_type)",children:"Stack (Abstract data type)"})]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.a,{href:"https://www.youtube.com/watch?v=RPQD7-AOjMI",children:"Video: Turing Complete (Computerphile)"})," Video describing what it means for a language to be Turing complete, the difference between the Bitcoin execution environment and the EVM is the EVM is Turing complete."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.a,{href:"https://ethereum.org/en/developers/docs/evm/",children:"Wiki: Ethereum Virtual Machine (Ethereum.org)"})," A deep dive describing the EVM"]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.a,{href:"https://takenobu-hs.github.io/downloads/ethereum_evm_illustrated.pdf",children:"Slides: Ethereum VM Illustrated (Takenobu T.)"})," A slide deck describing the Ethereum VM. Many of the diagrams in this section are from this slide deck"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8313:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/ag-blockchain-1-c5fbf2fa4b61cf1791f77846b77c0f56.png"},8146:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/evm-architecture-22857b14965a04427e031aa54f2724d2.png"},6028:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/evm-contract-accounts-1f7245261d6070126a4b0cd36808f9ab.png"},4231:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/evm-contract-creation-8529d1e62411a528d60c544c7cdffff8.png"},2689:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/evm-execution-model-2fcdefa0a533b076f656353a8070c6e0.png"},3621:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/evm-layers-a7615524ddc95a4683e6a457f14b3342.png"},2273:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/evm-txn-process-d9050206b8ee2afd49aaab109dd5215e.png"},6723:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/sc-mm-59a606202f3fe7fb4f11e3a3de8ebdb0.png"},1217:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/state-transition-0f15e9633e4cdbedfddd6f2d2e0cefba.png"},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var a=n(6540);const s={},i=a.createContext(s);function o(e){const t=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),a.createElement(i.Provider,{value:t},e.children)}}}]);